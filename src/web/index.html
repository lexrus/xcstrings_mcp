<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>xcstrings Translations</title>
    <style>
      :root {
        color-scheme: light;
      }
      * {
        box-sizing: border-box;
      }
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue",
          Arial, sans-serif;
        margin: 0;
        background: #f6f6f7;
        color: #1c1c1e;
      }
      .hidden {
        display: none !important;
      }
      main {
        width: 100%;
        margin: 0;
        padding: 4rem 3vw 2.5rem;
      }
      header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        margin-bottom: 1rem;
      }
      h1 {
        font-size: 2rem;
        font-weight: 700;
        letter-spacing: -0.02em;
        margin: 0;
      }
      nav.nav-bar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 30;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 0.6rem;
        padding: 0.6rem 3vw;
        background: #fff;
        border-bottom: 1px solid #d6d6db;
      }
      .nav-title {
        font-size: 1.1rem;
        font-weight: 700;
        letter-spacing: -0.02em;
        margin: 0;
        margin-right: 1rem;
      }
      .nav-left,
      .nav-center,
      .nav-right {
        display: flex;
        align-items: center;
        gap: 0.6rem;
      }
      .nav-left {
        flex: 1 1 16rem;
        flex-wrap: wrap;
      }
      .nav-center {
        flex: 1 1 auto;
        justify-content: center;
        flex-wrap: wrap;
        gap: 0.4rem 0.75rem;
      }
      .nav-label {
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #6e6e73;
      }
      .nav-right {
        flex: 0 0 auto;
      }
      .reference-row {
        opacity: 0.75;
      }
      input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
        vertical-align: middle;
        accent-color: #0a84ff;
      }
      input[type="checkbox"]:disabled {
        cursor: not-allowed;
        opacity: 0.5;
      }
      input:not(.search-field):not([type="checkbox"]),
      textarea {
        font-family:
          "Maple Mono NF CN", "JetBrainsMono", "SF Mono", Monaco,
          "Cascadia Code", "Roboto Mono", Consolas, "Courier New", monospace;
        font-size: 0.9rem;
        border-radius: 0;
        border: 1px solid #c7c7cd;
        background: #fff;
        padding: 0.4rem 0.6rem;
        transition:
          border-color 0.2s ease,
          background 0.2s ease;
        color: inherit;
      }
      textarea {
        resize: none;
        min-height: 2.6rem;
        overflow-y: hidden;
      }
      .translation-row:not(:hover):not(:focus-within)
        input:not(.search-field):not(:focus):not([type="checkbox"]),
      .translation-row:not(:hover):not(:focus-within) textarea:not(:focus),
      .translation-row:not(:hover):not(:focus-within) select:not(:focus) {
        border-color: transparent;
        background: transparent;
      }
      input:not(.search-field):not([type="checkbox"]):focus,
      textarea:focus {
        outline: none;
        border-color: #0a84ff;
        background: #fff;
      }
      input.comment-input {
        font-size: 0.7rem;
        color: #666;
        border: 1px solid transparent;
        background: transparent;
        padding: 0.25rem 0.5rem;
        width: 100%;
        height: 1.6rem;
      }
      .meta-row {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        flex-wrap: wrap;
      }
      .meta-select,
      .state-select {
        appearance: none;
        background: #fff;
        color: #1c1c1e;
        padding: 0.3rem 2rem 0.3rem 0.5rem;
        border-radius: 0;
        border: 1px solid #c7c7cd;
        font-size: 0.85rem;
        cursor: pointer;
      }
      .meta-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #6e6e73;
      }
      .meta-select:focus,
      .state-select:focus {
        outline: none;
        border-color: #0a84ff;
      }
      .state-options {
        display: flex;
        gap: 0.4rem;
        flex-wrap: wrap;
        align-items: center;
      }
      .state-dropdown {
        min-width: 140px;
        font-size: 0.75rem;
      }
      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: none;
      }
      .toast {
        background: #1c1c1e;
        color: #fff;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        font-size: 0.85rem;
        opacity: 0;
        transform: translateX(100%);
        animation: slideIn 0.3s ease forwards;
        pointer-events: all;
        max-width: 350px;
        word-wrap: break-word;
      }
      .toast.error {
        background: #d70015;
      }
      .toast.success {
        background: #239a3b;
      }
      @keyframes slideIn {
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }
      @keyframes slideOut {
        from {
          opacity: 1;
          transform: translateX(0);
        }
        to {
          opacity: 0;
          transform: translateX(100%);
        }
      }
      .toast.hiding {
        animation: slideOut 0.3s ease forwards;
      }
      .translation-input {
        border: 1px solid #c7c7cd;
        transition: border-color 0.2s ease;
      }
      .translation-input.state-positive {
        border-color: #239a3b;
      }
      .translation-input.state-warning {
        border-color: #c96a14;
      }
      input.comment-input:hover {
        border-color: #d1d1d6;
        background: #fafafa;
      }
      input.comment-input:focus {
        border-color: #0a84ff;
        background: #fff;
      }
      input.comment-input::placeholder {
        color: #c7c7cc;
      }
      .search-field {
        flex: 0 1 200px;
        font: inherit;
        border-radius: 0;
        border: 1px solid #c7c7cd;
        background: #fff;
        padding: 0.35rem 0.5rem;
        font-size: 0.85rem;
        transition: border-color 0.2s ease;
        color: inherit;
      }
      .search-field:focus {
        outline: none;
        border-color: #0a84ff;
        background: #fff;
      }
      button {
        font: inherit;
        border: 1px solid #1c1c1e;
        border-radius: 0;
        background: #1c1c1e;
        color: #fff;
        padding: 0.4rem 0.85rem;
        cursor: pointer;
        transition: background 0.15s ease;
      }
      button:hover {
        background: #0a84ff;
      }
      button:active {
        background: #005fcc;
      }
      button:disabled {
        background: #d6d6db;
        border-color: #d6d6db;
        color: #8e8e93;
        cursor: not-allowed;
      }
      button.secondary {
        border-color: #c7c7cd;
        background: #f0f0f2;
        color: #1c1c1e;
      }
      button.secondary:hover {
        background: #e0e0e5;
      }
      button.add-button {
        padding: 0.3rem 0.6rem;
        border-radius: 0;
        font-size: 0.9rem;
        line-height: 1.2;
      }
      .file-select-group {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        min-width: 12rem;
      }
      .language-select-wrapper,
      .file-select-wrapper {
        position: relative;
      }
      .language-select,
      .file-select {
        appearance: none;
        background: #fff;
        color: #1c1c1e;
        padding: 0.4rem 2rem 0.4rem 0.6rem;
        border-radius: 0;
        border: 1px solid #c7c7cd;
        min-width: 11rem;
        cursor: pointer;
        font-size: 0.9rem;
      }
      .file-select {
        min-width: 14rem;
      }
      .language-select:focus,
      .file-select:focus {
        outline: none;
        border-color: #0a84ff;
        background: #fff;
      }
      select:disabled,
      input:disabled,
      textarea:disabled {
        border-color: #e0e0e5;
        background: #f4f4f5;
        color: #8e8e93;
        cursor: not-allowed;
      }
      .language-select-wrapper::after,
      .file-select-wrapper::after {
        content: "\25BE";
        position: absolute;
        right: 0.9rem;
        top: 50%;
        transform: translateY(-50%);
        color: #6e6e73;
        pointer-events: none;
        font-size: 0.8rem;
      }
      .translation-row {
        transition: background 0.2s ease;
      }
      .translation-row:hover {
        background: rgba(245, 245, 247, 0.6);
      }
      .translation-row > td:first-child {
        border-left: 4px solid transparent;
        transition: border-color 0.2s ease;
      }
      .translation-row.state-positive > td:first-child {
        border-left-color: #239a3b;
      }
      .translation-row.state-warning > td:first-child {
        border-left-color: #c96a14;
      }
      .translation-row.collapsed .row-details {
        display: none;
      }
      .translation-row.collapsed .key-tools,
      .translation-row.collapsed .add-substitution-button {
        display: none;
      }
      .row-details {
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        margin-top: 0.6rem;
      }
      .key-header {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .row-expand {
        border: none;
        background: transparent;
        color: #6e6e73;
        cursor: pointer;
        padding: 0;
        width: 1.5rem;
        height: 1.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .row-expand:hover {
        color: #1c1c1e;
      }
      .row-expand:focus-visible {
        outline: 1px solid #0a84ff;
        outline-offset: 2px;
      }
      .lang-button {
        background: #f0f0f2;
        border: 1px solid #c7c7cd;
        color: #1c1c1e;
        padding: 0.3rem 0.65rem;
        border-radius: 0;
        font-size: 0.85rem;
      }
      .lang-button:hover {
        background: #e0e0e5;
      }
      .lang-button.active {
        background: #1c1c1e;
        color: #fff;
      }
      .lang-button.subtle {
        background: #f6f6f7;
        color: #3a3a3c;
        border-color: #e0e0e5;
      }
      .lang-button.subtle.active {
        background: #4b4acf;
        color: #fff;
      }
      .language-row {
        display: flex;
        gap: 0.4rem;
        flex-wrap: wrap;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        margin-top: 1.5rem;
        background: #fff;
        border: 1px solid #d6d6db;
      }
      th,
      td {
        padding: 0.75rem 1rem;
        border-bottom: 1px solid #e0e0e5;
        vertical-align: top;
      }
      th {
        text-align: left;
        font-size: 0.78rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #6e6e73;
        background: #f6f6f7;
      }
      tr:last-child td {
        border-bottom: none;
      }
      .key-cell {
        width: 30%;
      }
      .translation-cell {
        width: auto;
      }
      .key-wrapper {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .key-header {
        display: flex;
        align-items: center;
        gap: 0.4rem;
      }
      .key-input {
        flex: 1;
        width: 100%;
        font-size: 1rem;
        font-weight: 600;
        padding: 0.35rem 0.25rem;
        height: 2.2rem;
      }
      .key-tools {
        display: flex;
        gap: 0.3rem;
        position: relative;
      }
      .icon-button {
        background: #f0f0f2;
        border: 1px solid #c7c7cd;
        color: #1c1c1e;
        padding: 0.2rem 0.45rem;
        border-radius: 0;
        min-width: unset;
        font-size: 0.85rem;
      }
      .icon-button:hover {
        background: #e0e0e5;
      }
      .icon-button.subtle {
        background: transparent;
        border-color: transparent;
        color: #6e6e73;
      }
      .icon-button.subtle:hover {
        border-color: #c7c7cd;
        color: #1c1c1e;
        background: #f5f5f7;
      }
      .icon-button.danger {
        background: #fff4f3;
        border-color: #ffb3ad;
        color: #d70015;
      }
      .icon-button.danger:hover {
        background: #ffd8d3;
      }
      .translation-wrapper {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .translation-input {
        min-height: 1.2rem;
        width: 100%;
        overflow: hidden;
        margin-bottom: 0.7rem;
      }
      .reference-line {
        display: flex;
        gap: 0.35rem;
        align-items: center;
        font-size: 0.7rem;
        color: #636366;
        flex-wrap: warp;
        min-height: 1.6rem;
        padding: 0 0.5rem;
        background: #f9f9f9;
        border-left: 2px solid #e0e0e5;
      }
      .reference-line .reference-value {
        color: #1c1c1e;
        font-weight: 500;
        white-space: pre-wrap;
      }
      .status {
        margin-top: 1.2rem;
        color: #0a7;
        font-weight: 500;
        min-height: 1.2rem;
      }
      .status.error {
        color: #ff3b30;
      }
      .empty-placeholder {
        margin-top: 5rem;
        text-align: center;
        color: #6e6e73;
        font-size: 0.95rem;
      }
      .plural-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .substitutions-panel {
        margin-top: 0.8rem;
        border: 1px solid #d6d6db;
        background: #fdfdfd;
      }
      .substitutions-panel summary {
        padding: 0.45rem 0.75rem;
        font-size: 0.72rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #6e6e73;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .substitutions-panel summary::marker {
        display: none;
      }
      .substitutions-panel summary::-webkit-details-marker {
        display: none;
      }
      .substitutions-panel[open] summary {
        border-bottom: 1px solid #e0e0e5;
      }
      .substitutions-section {
        padding: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .substitution-block {
        border: 1px solid #e0e0e5;
        background: #fafafa;
        padding: 0.7rem;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }
      .substitution-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }
      .substitution-fields {
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
      }
      .substitution-field-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .substitution-field-label {
        min-width: 100px;
        font-size: 0.72rem;
        color: #48484a;
      }
      .substitution-fields input,
      .substitution-fields select,
      .substitution-fields textarea {
        flex: 1;
      }
      .substitution-actions {
        display: flex;
        gap: 0.4rem;
        flex-wrap: wrap;
      }
      .variation-section {
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
      }
      .variation-block {
        border: 1px solid #e0e0e5;
        background: #fff;
        padding: 0.6rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .variation-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }
      .variation-cases {
        display: flex;
        flex-direction: column;
        gap: 0.45rem;
      }
      .variation-row {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
      }
      .variation-case-label {
        font-family:
          "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas,
          "Courier New", monospace;
        font-size: 0.78rem;
        color: #636366;
      }
      .variation-row-content {
        display: flex;
        gap: 0.5rem;
        align-items: flex-start;
      }
      .variation-row-content textarea {
        flex: 1;
        resize: none;
        min-height: 2rem;
      }
      .variation-actions,
      .variation-add-row {
        display: flex;
        gap: 0.4rem;
        flex-wrap: wrap;
        position: relative;
      }
      .variation-action {
        position: relative;
        display: inline-flex;
        align-items: center;
      }
      .variation-picker {
        position: absolute;
        top: 100%;
        right: 0;
        margin-top: 0.3rem;
        background: #fff;
        border: 1px solid #c7c7cd;
        padding: 0.4rem;
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        z-index: 20;
      }
      .variation-picker.hidden {
        display: none;
      }
      .variation-option {
        border: none;
        background: transparent;
        font-size: 0.8rem;
        color: #1c1c1e;
        text-align: left;
        padding: 0.2rem 0.4rem;
        cursor: pointer;
      }
      .variation-option:hover {
        background: #f0f0f2;
      }
      .plural-row {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
        margin-bottom: 0.75rem;
      }
      .plural-row label {
        font-family:
          "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas,
          "Courier New", monospace;
        font-size: 0.8rem;
        color: #636366;
        padding: 0 0.5rem;
        background: #f9f9f9;
        border-left: 2px solid #e0e0e5;
        height: 1.2rem;
        display: flex;
        align-items: center;
      }
      .plural-row-content {
        display: flex;
        gap: 0.5rem;
        align-items: flex-start;
      }
      .plural-row textarea {
        flex: 1;
        resize: none;
        overflow: hidden;
        min-height: 2rem;
      }

      .plural-picker {
        position: absolute;
        top: 100%;
        left: 0;
        margin-top: 0.3rem;
        background: #fff;
        border: 1px solid #c7c7cd;
        padding: 0.5rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        z-index: 10;
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        max-width: 300px;
      }
      .plural-picker.hidden {
        display: none;
      }
      .plural-option {
        background: #f0f0f2;
        border: 1px solid #c7c7cd;
        color: #1c1c1e;
        padding: 0.3rem 0.6rem;
        border-radius: 0;
        font-size: 0.8rem;
        cursor: pointer;
        transition: background 0.2s ease;
      }
      .plural-option:hover {
        background: #e0e0e5;
      }
      .plural-empty {
        font-style: italic;
        color: #636366;
      }
      .plural-row .danger {
        width: 32px;
        height: 32px;
      }
      @media (max-width: 900px) {
        main {
          padding: 4.5rem 1.25rem 2.5rem;
        }
        nav.nav-bar {
          padding: 0.6rem 1.25rem;
          gap: 0.6rem;
        }
        .nav-left,
        .nav-center,
        .nav-right {
          flex: 1 1 100%;
          justify-content: center;
        }
        .nav-right {
          justify-content: flex-end;
        }
        .file-select-group {
          width: 100%;
        }
        table,
        thead,
        tbody,
        th,
        td,
        tr {
          display: block;
        }
        thead {
          display: none;
        }
        tr {
          margin-bottom: 1.25rem;
          border: 1px solid #d6d6db;
          border-radius: 0;
          padding: 0.75rem;
          background: #fff;
        }
        td {
          border: none;
          padding: 0.5rem 0;
        }
        .key-wrapper {
          flex-direction: column;
          gap: 0.4rem;
        }
      }
    </style>
  </head>
  <body>
    <nav class="nav-bar">
      <div class="nav-left">
        <div class="file-select-group">
          <div class="file-select-wrapper">
            <select
              id="file-select"
              class="language-select file-select"
              title="Choose xcstrings file"
            ></select>
          </div>
        </div>
        <input
          type="text"
          id="search"
          class="search-field"
          placeholder="Search keys or translations"
        />
      </div>
      <div class="nav-center">
        <label class="nav-label" for="language-select">Language</label>
        <div class="language-select-wrapper">
          <select
            id="language-select"
            class="language-select"
            title="Choose language"
          ></select>
        </div>
        <label class="nav-label" for="reference-select">Reference</label>
        <div class="language-select-wrapper">
          <select
            id="reference-select"
            class="language-select"
            title="Choose reference language"
          ></select>
        </div>
      </div>
      <div class="nav-right">
        <button class="add-button" id="add-translation" title="Add translation">
          ＋
        </button>
      </div>
    </nav>
    <main>
      <div id="empty-placeholder" class="empty-placeholder hidden">
        No .xcstrings files found. Add one to the project.
      </div>
      <div id="status" class="status"></div>
      <table id="translations-table">
        <thead>
          <tr>
            <th>Key</th>
            <th id="language-header">Translation</th>
          </tr>
        </thead>
        <tbody id="translations-body"></tbody>
      </table>
    </main>
    <div class="toast-container" id="toast-container"></div>
    <script>
      const LANGUAGE_REGIONS = {
        en: "US",
        "en-gb": "GB",
        "en-us": "US",
        fr: "FR",
        de: "DE",
        es: "ES",
        it: "IT",
        ja: "JP",
        ko: "KR",
        zh: "CN",
        "zh-hans": "CN",
        "zh-hant": "CN",
        pt: "PT",
        "pt-br": "BR",
        ru: "RU",
        nl: "NL",
        sv: "SE",
        da: "DK",
        fi: "FI",
        nb: "NO",
        pl: "PL",
        cs: "CZ",
      };

      const LANGUAGE_LABELS = {
        en: "English",
        "en-gb": "English (UK)",
        "en-us": "English (US)",
        fr: "French",
        de: "German",
        es: "Spanish",
        it: "Italian",
        ja: "Japanese",
        ko: "Korean",
        zh: "Chinese",
        "zh-hans": "Chinese (Simplified)",
        "zh-hant": "Chinese (Traditional)",
        pt: "Portuguese",
        "pt-br": "Portuguese (Brazil)",
        ru: "Russian",
        nl: "Dutch",
        sv: "Swedish",
        da: "Danish",
        fi: "Finnish",
        nb: "Norwegian",
        pl: "Polish",
        cs: "Czech",
      };

      const PLURAL_CASES = ["zero", "one", "two", "few", "many", "other"];
      const EXTRACTION_STATES = ["manual", "stale", "extracted"];
      const TRANSLATION_STATES = [
        "",
        "translated",
        "needs_review",
        "new",
        "missing",
        "untranslated",
      ];
      const TRANSLATION_STATE_LABELS = {
        "": "Unset",
        translated: "Translated",
        needs_review: "Needs review",
        new: "New",
        missing: "Missing",
        untranslated: "Untranslated",
      };
      const DEVICE_CASES = [
        "appletv",
        "applevision",
        "applewatch",
        "ipad",
        "iphone",
        "ipod",
        "mac",
        "other",
      ];
      const DEVICE_CASE_LABELS = {
        appletv: "Apple TV",
        applevision: "Apple Vision",
        applewatch: "Apple Watch",
        ipad: "iPad",
        iphone: "iPhone",
        ipod: "iPod",
        mac: "Mac",
        other: "Other",
      };
      const VARIATION_SELECTORS = {
        plural: { label: "Plural", cases: PLURAL_CASES },
        device: { label: "Device", cases: DEVICE_CASES },
      };
      const state = {
        files: [],
        currentPath: null,
        languages: [],
        translationPercentages: {},
        currentLanguage: null,
        referenceLanguage: null,
        items: [],
        drafts: [],
      };
      const expandedRows = new Set();
      let pendingScrollRestore = null;

      const SAMPLE_MODE = window.location.protocol === "file:";
      const SAMPLE_DATA = {
        languages: ["en", "fr", "de"],
        items: [
          {
            key: "welcome_title",
            comment: "Shown at the top of the dashboard",
            extractionState: "manual",
            translations: {
              en: { value: "Welcome" },
              fr: { value: "Bienvenue" },
              de: { value: "Willkommen" },
            },
          },
          {
            key: "items_count",
            comment: "Displays the current number of tracked items",
            extractionState: "manual",
            translations: {
              en: {
                value: "{count} item",
                variations: {
                  plural: {
                    one: { value: "{count} item" },
                    other: { value: "{count} items" },
                  },
                },
              },
              fr: {
                value: "{count} objet",
                variations: {
                  plural: {
                    one: { value: "{count} objet" },
                    other: { value: "{count} objets" },
                  },
                },
              },
              de: {
                value: "{count} Element",
                variations: {
                  plural: {
                    one: { value: "{count} Element" },
                    other: { value: "{count} Elemente" },
                  },
                },
              },
            },
          },
          {
            key: "sync_status",
            comment: "Banner shown while syncing with the localization service",
            extractionState: "automatic",
            translations: {
              en: { value: "Syncing latest content..." },
              fr: { value: "Synchronisation du contenu..." },
              de: { value: "Inhalte werden synchronisiert ..." },
            },
          },
        ],
      };
      const sampleStore = SAMPLE_MODE
        ? JSON.parse(JSON.stringify(SAMPLE_DATA))
        : null;

      function languageLabel(code) {
        if (!code) {
          return "";
        }
        const normalized = code.toLowerCase();
        if (LANGUAGE_LABELS[normalized]) {
          return LANGUAGE_LABELS[normalized];
        }
        const base = normalized.split(/[-_]/)[0];
        if (LANGUAGE_LABELS[base]) {
          return LANGUAGE_LABELS[base];
        }
        return code;
      }

      function formatLanguageDisplay(code, showPercentage = false) {
        if (!code) {
          return "";
        }
        const percentage = state.translationPercentages[code];
        if (showPercentage && percentage !== undefined) {
          return `${languageLabel(code)} (${code}) - ${percentage.toFixed(0)}%`;
        }
        return `${languageLabel(code)} (${code})`;
      }

      function translationStateLabel(value) {
        const normalized = value || "";
        if (TRANSLATION_STATE_LABELS[normalized] !== undefined) {
          return TRANSLATION_STATE_LABELS[normalized];
        }
        return normalized
          .split("_")
          .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
          .join(" ");
      }

      function applyTranslationStateStyles(textarea, stateValue) {
        if (!textarea) {
          return;
        }
        const normalized = stateValue || "";
        textarea.classList.remove("state-positive", "state-warning");
        if (normalized === "translated" || normalized === "verified") {
          textarea.classList.add("state-positive");
        } else if (normalized) {
          textarea.classList.add("state-warning");
        }
      }

      function applyRowStateStyles(row, stateValue) {
        if (!row) {
          return;
        }
        const normalized = stateValue || "";
        row.classList.remove("state-positive", "state-warning");
        if (normalized === "translated" || normalized === "verified") {
          row.classList.add("state-positive");
        } else if (normalized) {
          row.classList.add("state-warning");
        }
      }

      function captureScrollPosition() {
        pendingScrollRestore = window.scrollY;
      }

      function restoreScrollPositionIfNeeded() {
        if (pendingScrollRestore === null) {
          return;
        }
        const target = pendingScrollRestore;
        pendingScrollRestore = null;
        requestAnimationFrame(() => {
          window.scrollTo(0, target);
        });
      }

      function isInteractiveTarget(target) {
        return Boolean(
          target.closest(
            "input, textarea, select, button, a, .plural-picker, .variation-picker",
          ),
        );
      }

      function availableVariationCases(selector, existingKeys) {
        const config = VARIATION_SELECTORS[selector];
        if (!config) {
          return [];
        }
        return config.cases.filter(
          (caseKey) => !existingKeys.includes(caseKey),
        );
      }

      function variationLabel(selector) {
        const config = VARIATION_SELECTORS[selector];
        if (config) {
          return config.label;
        }
        return selector.charAt(0).toUpperCase() + selector.slice(1);
      }

      function getCaseLabel(selector, caseKey) {
        if (selector === "device" && DEVICE_CASE_LABELS[caseKey]) {
          return DEVICE_CASE_LABELS[caseKey];
        }
        return caseKey;
      }

      function pruneTranslationInPlace(node) {
        if (!node || typeof node !== "object") {
          return true;
        }

        if (node.value === null || node.value === undefined) {
          delete node.value;
        }
        if (
          node.state === null ||
          node.state === undefined ||
          node.state === ""
        ) {
          delete node.state;
        }

        if (node.variations) {
          Object.entries(node.variations).forEach(([selector, cases]) => {
            if (!cases || typeof cases !== "object") {
              delete node.variations[selector];
              return;
            }
            Object.entries(cases).forEach(([caseKey, entry]) => {
              if (!entry || typeof entry !== "object") {
                delete cases[caseKey];
                return;
              }
              if (pruneTranslationInPlace(entry)) {
                delete cases[caseKey];
              }
            });
            if (Object.keys(cases).length === 0) {
              delete node.variations[selector];
            }
          });
          if (Object.keys(node.variations).length === 0) {
            delete node.variations;
          }
        }

        if (node.substitutions) {
          Object.entries(node.substitutions).forEach(([name, sub]) => {
            if (pruneSubstitutionInPlace(sub)) {
              delete node.substitutions[name];
            }
          });
          if (Object.keys(node.substitutions).length === 0) {
            delete node.substitutions;
          }
        }

        const hasValue = node.value !== undefined;
        const hasState = node.state !== undefined;
        const hasVariations =
          node.variations && Object.keys(node.variations).length > 0;
        const hasSubstitutions =
          node.substitutions && Object.keys(node.substitutions).length > 0;

        return !hasValue && !hasState && !hasVariations && !hasSubstitutions;
      }

      function pruneSubstitutionInPlace(substitution) {
        if (!substitution || typeof substitution !== "object") {
          return true;
        }

        if (substitution.substitutions !== undefined) {
          delete substitution.substitutions;
        }

        if (substitution.value === null || substitution.value === undefined) {
          delete substitution.value;
        }
        if (
          substitution.state === null ||
          substitution.state === undefined ||
          substitution.state === ""
        ) {
          delete substitution.state;
        }
        if (substitution.argNum === null || substitution.argNum === undefined) {
          delete substitution.argNum;
        }
        if (
          substitution.formatSpecifier === null ||
          substitution.formatSpecifier === undefined ||
          substitution.formatSpecifier === ""
        ) {
          delete substitution.formatSpecifier;
        }

        if (substitution.variations) {
          Object.entries(substitution.variations).forEach(
            ([selector, cases]) => {
              if (!cases || typeof cases !== "object") {
                delete substitution.variations[selector];
                return;
              }
              Object.entries(cases).forEach(([caseKey, entry]) => {
                if (!entry || typeof entry !== "object") {
                  delete cases[caseKey];
                  return;
                }
                if (pruneTranslationInPlace(entry)) {
                  delete cases[caseKey];
                }
              });
              if (Object.keys(cases).length === 0) {
                delete substitution.variations[selector];
              }
            },
          );
          if (Object.keys(substitution.variations).length === 0) {
            delete substitution.variations;
          }
        }

        const hasValue = substitution.value !== undefined;
        const hasState = substitution.state !== undefined;
        const hasArgNum = substitution.argNum !== undefined;
        const hasFormat = substitution.formatSpecifier !== undefined;
        const hasVariations =
          substitution.variations &&
          Object.keys(substitution.variations).length > 0;

        return (
          !hasValue && !hasState && !hasArgNum && !hasFormat && !hasVariations
        );
      }

      function translationHeaderText() {
        if (!state.currentLanguage) {
          return "Translation";
        }
        return `Translation — ${formatLanguageDisplay(state.currentLanguage)}`;
      }

      function dropDraft(draftId) {
        if (!draftId) {
          return;
        }
        state.drafts = state.drafts.filter(
          (draft) => draft.__draftId !== draftId,
        );
        expandedRows.delete(draftId);
      }

      function renderLanguageControls() {
        const languageSelect = document.getElementById("language-select");
        const referenceSelect = document.getElementById("reference-select");
        languageSelect.innerHTML = "";
        referenceSelect.innerHTML = "";

        const englishCandidate =
          state.languages.find((lang) => lang.toLowerCase() === "en") ||
          state.languages.find((lang) => lang.toLowerCase().startsWith("en-"));

        if (
          !state.currentLanguage ||
          !state.languages.includes(state.currentLanguage)
        ) {
          state.currentLanguage =
            englishCandidate || state.languages[0] || null;
        }

        if (
          !state.referenceLanguage ||
          !state.languages.includes(state.referenceLanguage)
        ) {
          state.referenceLanguage =
            state.currentLanguage ||
            englishCandidate ||
            state.languages[0] ||
            null;
        }

        state.languages.forEach((lang) => {
          const option = document.createElement("option");
          option.value = lang;
          option.textContent = formatLanguageDisplay(lang, true); // Show percentage
          languageSelect.appendChild(option);

          const refOption = document.createElement("option");
          refOption.value = lang;
          refOption.textContent = formatLanguageDisplay(lang, false); // No percentage
          referenceSelect.appendChild(refOption);
        });

        if (
          state.currentLanguage &&
          state.languages.includes(state.currentLanguage)
        ) {
          languageSelect.value = state.currentLanguage;
        } else if (state.languages.length) {
          state.currentLanguage = state.languages[0];
          languageSelect.value = state.currentLanguage;
        } else {
          languageSelect.value = "";
        }

        if (
          state.referenceLanguage &&
          state.languages.includes(state.referenceLanguage)
        ) {
          referenceSelect.value = state.referenceLanguage;
        } else if (state.languages.length) {
          state.referenceLanguage = state.currentLanguage || state.languages[0];
          referenceSelect.value = state.referenceLanguage;
        } else {
          referenceSelect.value = "";
        }

        document.getElementById("language-header").textContent =
          translationHeaderText();

        if (!state.languages.length) {
          state.currentLanguage = null;
          state.referenceLanguage = null;
        }

        updateControlState();
      }

      function updateControlState() {
        const hasFiles = SAMPLE_MODE || state.files.length > 0;
        const placeholder = document.getElementById("empty-placeholder");
        const table = document.getElementById("translations-table");
        const languageSelect = document.getElementById("language-select");
        const referenceSelect = document.getElementById("reference-select");
        const searchInput = document.getElementById("search");
        const addButton = document.getElementById("add-translation");

        placeholder.classList.toggle("hidden", hasFiles);
        table.classList.toggle("hidden", !hasFiles);

        languageSelect.disabled = !hasFiles || !state.languages.length;
        referenceSelect.disabled = !hasFiles || !state.languages.length;
        searchInput.disabled = !hasFiles && !SAMPLE_MODE;
        addButton.disabled = !hasFiles || !state.currentLanguage;
      }

      function renderFileSelector() {
        const select = document.getElementById("file-select");
        select.innerHTML = "";

        if (!state.files.length) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "No xcstrings files";
          select.appendChild(option);
          select.disabled = true;
          updateControlState();
          return;
        }

        if (
          state.currentPath &&
          !state.files.some((file) => file.path === state.currentPath)
        ) {
          state.currentPath = state.files[0].path;
        }

        state.files.forEach((file) => {
          const option = document.createElement("option");
          option.value = file.path;
          option.textContent = file.label || file.path;
          if (file.path === state.currentPath) {
            option.selected = true;
          }
          select.appendChild(option);
        });

        if (state.currentPath) {
          select.value = state.currentPath;
        }

        select.disabled = SAMPLE_MODE && state.files.length === 1;

        updateControlState();
      }

      async function fetchLanguages() {
        if (!state.currentPath && !SAMPLE_MODE) {
          state.languages = [];
          state.translationPercentages = {};
          renderLanguageControls();
          return;
        }
        if (SAMPLE_MODE) {
          state.languages = sampleStore.languages.slice();
          state.translationPercentages = {};
          renderLanguageControls();
          return;
        }
        try {
          const params = new URLSearchParams({ path: state.currentPath });
          const res = await fetch(`/api/languages?${params.toString()}`);
          if (!res.ok) {
            throw new Error(`Request failed with status ${res.status}`);
          }
          const data = await res.json();
          state.languages = data.languages || [];

          // Fetch translation percentages
          const percentRes = await fetch(`/api/translation-percentages?${params.toString()}`);
          if (percentRes.ok) {
            const percentData = await percentRes.json();
            state.translationPercentages = percentData.percentages || {};
          } else {
            state.translationPercentages = {};
          }
        } catch (error) {
          console.error(error);
          state.languages = [];
          state.translationPercentages = {};
          setStatus("Failed to load languages", true);
        }
        renderLanguageControls();
      }

      async function fetchTranslations(query = "") {
        if (!state.currentPath && !SAMPLE_MODE) {
          state.items = [];
          state.drafts = [];
          renderTable();
          return;
        }
        if (pendingScrollRestore === null) {
          captureScrollPosition();
        }
        if (SAMPLE_MODE) {
          const normalized = query.trim().toLowerCase();
          const filtered = !normalized
            ? sampleStore.items
            : sampleStore.items.filter((item) => {
                const bucket = [];
                bucket.push(item.key || "");
                if (item.comment) {
                  bucket.push(item.comment);
                }
                sampleStore.languages.forEach((lang) => {
                  const translation = item.translations?.[lang];
                  if (!translation) {
                    return;
                  }
                  if (translation.value) {
                    bucket.push(translation.value);
                  }
                  const plural = translation.variations?.plural || {};
                  Object.values(plural).forEach((entry) => {
                    if (entry?.value) {
                      bucket.push(entry.value);
                    }
                  });
                  const device = translation.variations?.device || {};
                  Object.values(device).forEach((entry) => {
                    if (entry?.value) {
                      bucket.push(entry.value);
                    }
                  });
                  const substitutions = translation.substitutions || {};
                  Object.values(substitutions).forEach((sub) => {
                    if (sub?.value) {
                      bucket.push(sub.value);
                    }
                    const subPlural = sub?.variations?.plural || {};
                    Object.values(subPlural).forEach((entry) => {
                      if (entry?.value) {
                        bucket.push(entry.value);
                      }
                    });
                    const subDevice = sub?.variations?.device || {};
                    Object.values(subDevice).forEach((entry) => {
                      if (entry?.value) {
                        bucket.push(entry.value);
                      }
                    });
                  });
                });
                return bucket.join(" ").toLowerCase().includes(normalized);
              });

          state.items = filtered.map((item) =>
            JSON.parse(JSON.stringify(item)),
          );
        } else {
          try {
            const params = new URLSearchParams({ path: state.currentPath });
            const trimmed = query.trim();
            if (trimmed) {
              params.set("q", trimmed);
            }
            const res = await fetch(`/api/translations?${params.toString()}`);
            if (!res.ok) {
              throw new Error(`Request failed with status ${res.status}`);
            }
            const data = await res.json();
            state.items = data.items || [];
          } catch (error) {
            console.error(error);
            state.items = [];
            setStatus("Failed to load translations", true);
          }
        }

        state.drafts = state.drafts.filter((draft) => {
          if (!draft.key) {
            return true;
          }
          return !state.items.some((item) => item.key === draft.key);
        });
        renderTable();
      }

      async function loadFiles() {
        if (SAMPLE_MODE) {
          state.files = [{ path: "sample", label: "Sample data" }];
          state.currentPath = "sample";
          state.drafts = [];
          renderFileSelector();
          await fetchLanguages();
          await fetchTranslations(
            document.getElementById("search").value || "",
          );
          return;
        }

        try {
          const res = await fetch("/api/files");
          if (!res.ok) {
            throw new Error(`Request failed with status ${res.status}`);
          }
          const data = await res.json();
          state.files = Array.isArray(data.files) ? data.files : [];

          if (state.files.length) {
            const preserved =
              state.currentPath &&
              state.files.some((file) => file.path === state.currentPath)
                ? state.currentPath
                : null;
            const defaultCandidate =
              data.default &&
              state.files.some((file) => file.path === data.default)
                ? data.default
                : null;
            state.currentPath =
              preserved || defaultCandidate || state.files[0].path;
          } else {
            state.currentPath = null;
          }

          state.drafts = [];
          renderFileSelector();

          if (state.currentPath) {
            await fetchLanguages();
            const query = document.getElementById("search").value || "";
            await fetchTranslations(query);
          } else {
            state.languages = [];
            state.items = [];
            renderLanguageControls();
            renderTable();
          }
        } catch (error) {
          console.error(error);
          setStatus("Failed to load xcstrings files", true);
          state.files = [];
          state.currentPath = null;
          state.languages = [];
          state.items = [];
          state.drafts = [];
          renderFileSelector();
          renderLanguageControls();
          renderTable();
        }
      }

      function referenceFor(item) {
        if (!state.referenceLanguage) {
          return null;
        }
        return item.translations[state.referenceLanguage] || null;
      }

      function autoResizeTextarea(textarea) {
        textarea.style.height = "auto";
        textarea.style.height = textarea.scrollHeight + "px";
      }

      function initAutoResize(textarea) {
        autoResizeTextarea(textarea);
        textarea.addEventListener("input", () => autoResizeTextarea(textarea));
      }

      function renderTable() {
        const tbody = document.getElementById("translations-body");
        if (!tbody) {
          return;
        }
        const rows = [...state.drafts, ...state.items];
        const seenRowIds = new Set();
        tbody.innerHTML = "";

        rows.forEach((item, index) => {
          const isDraft = Boolean(item.__draft);
          if (!item.translations) {
            item.translations = {};
          }

          const tr = document.createElement("tr");
          tr.className = "translation-row";

          const rowId = isDraft
            ? item.__draftId || `draft-${index}`
            : item.key || `row-${index}`;
          tr.dataset.rowId = rowId;
          seenRowIds.add(rowId);

          const ensureExpanded = () => {
            expandedRows.add(rowId);
            syncExpansion();
          };

          const ensureCollapsed = () => {
            expandedRows.delete(rowId);
            syncExpansion();
          };

          const keyCell = document.createElement("td");
          keyCell.className = "key-cell";
          const keyWrapper = document.createElement("div");
          keyWrapper.className = "key-wrapper";

          let activeKey = item.key || "";

          const commentInput = document.createElement("input");
          commentInput.type = "text";
          commentInput.className = "comment-input";
          commentInput.placeholder = "// comment";
          commentInput.value = item.comment || "";
          commentInput.addEventListener("change", async (event) => {
            if (!activeKey) {
              setStatus("Set a key before saving comments", true);
              commentInput.value = "";
              return;
            }
            if (isDraft) {
              setStatus("Save the translation before adding comments", true);
              commentInput.value = item.comment || "";
              return;
            }
            if (SAMPLE_MODE) {
              const target = sampleStore.items.find(
                (entry) => entry.key === activeKey,
              );
              if (!target) {
                setStatus("Save the translation before adding comments", true);
                commentInput.value = item.comment || "";
                return;
              }
              target.comment = event.target.value || "";
              item.comment = target.comment;
              setStatus("Comment saved");
              return;
            }
            if (!state.currentPath) {
              setStatus("Select a file before saving comments", true);
              commentInput.value = item.comment || "";
              return;
            }
            const res = await fetch("/api/comments", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                key: activeKey,
                path: state.currentPath,
                comment: event.target.value || null,
              }),
            });
            if (res.ok) {
              item.comment = event.target.value;
              setStatus("Comment saved");
            } else {
              setStatus("Failed to save comment", true);
            }
          });
          const keyHeader = document.createElement("div");
          keyHeader.className = "key-header";

          const expandToggle = document.createElement("button");
          expandToggle.type = "button";
          expandToggle.className = "row-expand";
          expandToggle.title = "Toggle details";
          expandToggle.setAttribute("aria-label", "Toggle details");
          keyHeader.appendChild(expandToggle);

          const syncExpansion = () => {
            const expanded = expandedRows.has(rowId);
            expandToggle.textContent = expanded ? "▾" : "▸";
            expandToggle.setAttribute(
              "aria-expanded",
              expanded ? "true" : "false",
            );
            tr.classList.toggle("collapsed", !expanded);
          };

          if (expandedRows.has(rowId)) {
            ensureExpanded();
          } else {
            ensureCollapsed();
          }

          expandToggle.addEventListener("click", (event) => {
            event.stopPropagation();
            if (expandedRows.has(rowId)) {
              ensureCollapsed();
            } else {
              ensureExpanded();
            }
          });

          tr.addEventListener("click", (event) => {
            if (isInteractiveTarget(event.target)) {
              return;
            }
            if (!expandedRows.has(rowId)) {
              ensureExpanded();
            }
          });

          const keyInput = document.createElement("input");
          keyInput.type = "text";
          keyInput.className = "key-input";
          keyInput.value = activeKey;
          keyInput.placeholder = isDraft ? "New key" : "";
          keyInput.spellcheck = false;
          if (isDraft) {
            keyInput.dataset.draft = item.__draftId;
          }

          keyInput.addEventListener("focus", () => {
            keyInput.setSelectionRange(0, keyInput.value.length);
          });
          keyInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
              event.preventDefault();
              keyInput.blur();
            } else if (event.key === "Escape") {
              keyInput.value = activeKey;
              keyInput.blur();
            }
          });
          keyInput.addEventListener("blur", async () => {
            const nextKey = keyInput.value.trim();
            if (!nextKey) {
              setStatus("Key cannot be empty", true);
              if (isDraft) {
                keyInput.value = "";
              } else {
                keyInput.value = activeKey;
              }
              return;
            }
            if (nextKey === activeKey) {
              keyInput.value = activeKey;
              return;
            }
            if (isDraft) {
              activeKey = nextKey;
              item.key = nextKey;
              setStatus("Key ready");
              return;
            }
            try {
              await renameKey(activeKey, nextKey);
              if (!isDraft && expandedRows.has(rowId)) {
                expandedRows.delete(rowId);
                expandedRows.add(nextKey);
              }
              activeKey = nextKey;
              setStatus("Key renamed");
              captureScrollPosition();
              await fetchTranslations(document.getElementById("search").value);
            } catch (error) {
              setStatus(error.message, true);
              keyInput.value = activeKey;
            }
          });

          keyHeader.appendChild(keyInput);
          keyWrapper.appendChild(keyHeader);

          keyWrapper.appendChild(commentInput);

          const keyDetails = document.createElement("div");
          keyDetails.className = "row-details";
          let keyDetailsHasContent = false;

          const metaRow = document.createElement("div");
          metaRow.className = "meta-row";

          const extractionLabel = document.createElement("span");
          extractionLabel.className = "meta-label";
          extractionLabel.textContent = "Extraction";
          metaRow.appendChild(extractionLabel);

          const extractionSelect = document.createElement("select");
          extractionSelect.className = "meta-select";
          const extractionOptions = ["", ...EXTRACTION_STATES];
          extractionOptions.forEach((option) => {
            const opt = document.createElement("option");
            opt.value = option;
            opt.textContent = option ? option : "(default)";
            extractionSelect.appendChild(opt);
          });
          extractionSelect.value = item.extractionState || "";
          extractionSelect.disabled = isDraft;
          extractionSelect.addEventListener("change", async (event) => {
            const next = event.target.value || null;
            if (!activeKey) {
              item.extractionState = next;
              return;
            }
            if (isDraft) {
              item.extractionState = next;
              return;
            }
            try {
              await updateExtractionState(activeKey, next);
              item.extractionState = next;
            } catch (error) {
              setStatus(error.message, true);
              extractionSelect.value = item.extractionState || "";
            }
          });
          metaRow.appendChild(extractionSelect);

          const shouldTranslateLabel = document.createElement("span");
          shouldTranslateLabel.className = "meta-label";
          shouldTranslateLabel.textContent = "Should Translate";
          shouldTranslateLabel.style.marginLeft = "16px";
          metaRow.appendChild(shouldTranslateLabel);

          const shouldTranslateCheckbox = document.createElement("input");
          shouldTranslateCheckbox.type = "checkbox";
          shouldTranslateCheckbox.style.marginLeft = "6px";
          shouldTranslateCheckbox.checked = item.shouldTranslate === true;
          shouldTranslateCheckbox.indeterminate =
            item.shouldTranslate === null || item.shouldTranslate === undefined;
          shouldTranslateCheckbox.disabled = isDraft;
          shouldTranslateCheckbox.addEventListener("change", async (event) => {
            const next = event.target.checked ? true : null;
            if (!activeKey) {
              item.shouldTranslate = next;
              return;
            }
            if (isDraft) {
              item.shouldTranslate = next;
              return;
            }
            try {
              await updateShouldTranslate(activeKey, next);
              item.shouldTranslate = next;
            } catch (error) {
              setStatus(error.message, true);
              shouldTranslateCheckbox.checked = item.shouldTranslate === true;
              shouldTranslateCheckbox.indeterminate =
                item.shouldTranslate === null ||
                item.shouldTranslate === undefined;
            }
          });
          metaRow.appendChild(shouldTranslateCheckbox);

          keyDetails.appendChild(metaRow);
          keyDetailsHasContent = true;

          const keyTools = document.createElement("div");
          keyTools.className = "key-tools";

          const copyBtn = document.createElement("button");
          copyBtn.type = "button";
          copyBtn.className = "icon-button";
          copyBtn.title = "Copy key";
          copyBtn.textContent = "📋";
          copyBtn.addEventListener("click", async () => {
            if (!activeKey) {
              setStatus("Set a key before copying", true);
              return;
            }
            try {
              await navigator.clipboard.writeText(activeKey);
              setStatus("Key copied to clipboard");
            } catch (_) {
              setStatus("Copy not available in this browser", true);
            }
          });

          const deleteKeyBtn = document.createElement("button");
          deleteKeyBtn.type = "button";
          deleteKeyBtn.className = "icon-button danger";
          deleteKeyBtn.title = "Delete key";
          deleteKeyBtn.textContent = "🗑️";
          deleteKeyBtn.addEventListener("click", async () => {
            if (isDraft) {
              dropDraft(item.__draftId);
              renderTable();
              setStatus("Draft removed");
              return;
            }
            if (!activeKey) {
              return;
            }
            if (!confirm(`Delete key "${activeKey}" for all languages?`)) {
              return;
            }
            if (SAMPLE_MODE) {
              const index = sampleStore.items.findIndex(
                (entry) => entry.key === activeKey,
              );
              if (index === -1) {
                setStatus("Failed to delete key", true);
                return;
              }
              sampleStore.items.splice(index, 1);
              setStatus("Key deleted");
              captureScrollPosition();
              await fetchTranslations(document.getElementById("search").value);
              return;
            }
            if (!state.currentPath) {
              setStatus("Select a file before deleting keys", true);
              return;
            }
            const deleteParams = new URLSearchParams({
              path: state.currentPath,
            });
            const res = await fetch(
              `/api/keys/${encodeURIComponent(activeKey)}?${deleteParams.toString()}`,
              { method: "DELETE" },
            );
            if (res.ok) {
              setStatus("Key deleted");
              captureScrollPosition();
              await fetchTranslations(document.getElementById("search").value);
            } else {
              let message = "Failed to delete key";
              try {
                const err = await res.json();
                if (err?.error) {
                  message = err.error;
                }
              } catch (_) {
                // ignore
              }
              setStatus(message, true);
            }
          });

          keyTools.appendChild(copyBtn);
          keyTools.appendChild(deleteKeyBtn);
          keyDetails.appendChild(keyTools);
          keyDetailsHasContent = true;

          if (keyDetailsHasContent) {
            keyWrapper.appendChild(keyDetails);
          }
          keyCell.appendChild(keyWrapper);
          tr.appendChild(keyCell);

          const translationCell = document.createElement("td");
          translationCell.className = "translation-cell";
          const translationWrapper = document.createElement("div");
          translationWrapper.className = "translation-wrapper";

          const reference =
            !isDraft && state.referenceLanguage ? referenceFor(item) : null;
          if (reference) {
            const refLine = document.createElement("div");
            refLine.className = "reference-line";

            const refLabel = document.createElement("span");
            refLabel.textContent = formatLanguageDisplay(
              state.referenceLanguage,
            );

            const separator = document.createElement("span");
            separator.textContent = "—";

            const refValue = document.createElement("span");
            refValue.className = "reference-value";
            refValue.textContent = reference.value ? reference.value : "—";

            refLine.appendChild(refLabel);
            refLine.appendChild(separator);
            refLine.appendChild(refValue);

            translationWrapper.appendChild(refLine);
          }

          if (
            state.currentLanguage &&
            !item.translations[state.currentLanguage]
          ) {
            item.translations[state.currentLanguage] = {};
          }
          const translation = state.currentLanguage
            ? item.translations[state.currentLanguage] || {}
            : {};

          let translationTextarea;
          const translationDetails = document.createElement("div");
          translationDetails.className = "row-details translation-details";
          let translationDetailsHasContent = false;

          const translationMeta = document.createElement("div");
          translationMeta.className = "meta-row";

          const translationLabel = document.createElement("span");
          translationLabel.className = "meta-label";
          translationLabel.textContent = "State";
          translationMeta.appendChild(translationLabel);

          const stateDropdown = document.createElement("select");
          stateDropdown.className = "state-dropdown";
          stateDropdown.disabled = !state.currentLanguage;

          const updateStateVisuals = () => {
            applyTranslationStateStyles(translationTextarea, translation.state);
            applyRowStateStyles(tr, translation.state);
          };

          TRANSLATION_STATES.forEach((option) => {
            const normalized = option || "";
            const optionElem = document.createElement("option");
            optionElem.value = normalized;
            optionElem.textContent = translationStateLabel(normalized);
            if ((translation.state || "") === normalized) {
              optionElem.selected = true;
            }
            stateDropdown.appendChild(optionElem);
          });

          stateDropdown.addEventListener("change", async (event) => {
            const previous = translation.state || "";
            const nextStateValue = event.target.value || null;

            if (!state.currentLanguage) {
              setStatus("Select a language before editing state", true);
              translation.state = previous ? previous : null;
              stateDropdown.value = previous;
              updateStateVisuals();
              return;
            }

            if (!activeKey) {
              translation.state = nextStateValue;
              updateStateVisuals();
              return;
            }

            try {
              await updateTranslationState(
                activeKey,
                state.currentLanguage,
                nextStateValue,
              );
              translation.state = nextStateValue;
            } catch (error) {
              setStatus(error.message, true);
              translation.state = previous ? previous : null;
              stateDropdown.value = previous;
            }

            updateStateVisuals();
          });

          translationMeta.appendChild(stateDropdown);
          translationDetails.appendChild(translationMeta);
          translationDetailsHasContent = true;

          translationTextarea = document.createElement("textarea");
          translationTextarea.className = "translation-input";
          translationTextarea.placeholder = `Enter ${languageLabel(state.currentLanguage || "")} translation`;
          translationTextarea.value = translation.value || "";
          translationTextarea.addEventListener("change", async (event) => {
            if (!state.currentLanguage) {
              setStatus("Select a language before saving", true);
              return;
            }
            if (!activeKey) {
              setStatus("Set a key before saving a translation", true);
              translationTextarea.value = translation.value || "";
              return;
            }
            try {
              await upsertTranslation(
                {
                  key: activeKey,
                  language: state.currentLanguage,
                  value: event.target.value,
                },
                "Translation saved",
              );
              if (isDraft) {
                dropDraft(item.__draftId);
                captureScrollPosition();
                await fetchTranslations(
                  document.getElementById("search").value,
                );
              } else {
                translation.value = event.target.value;
              }
            } catch (error) {
              setStatus(error.message, true);
              translationTextarea.value = translation.value || "";
            }
          });

          translationWrapper.appendChild(translationTextarea);
          requestAnimationFrame(() => {
            initAutoResize(translationTextarea);
            updateStateVisuals();
          });

          const pluralVariations =
            (translation.variations && translation.variations.plural) || {};
          const deviceVariations =
            (translation.variations && translation.variations.device) || {};
          const pluralKeys = Object.keys(pluralVariations);
          const deviceKeys = Object.keys(deviceVariations);

          // Display plural variations
          if (pluralKeys.length) {
            const pluralList = document.createElement("div");
            pluralList.className = "plural-list";

            pluralKeys.forEach((caseKey) => {
              const entry = pluralVariations[caseKey] || {};
              const row = document.createElement("div");
              row.className = "plural-row";

              const label = document.createElement("label");
              label.textContent = `plural: ${caseKey.toLowerCase()}`;
              row.appendChild(label);

              const rowContent = document.createElement("div");
              rowContent.className = "plural-row-content";

              const variantTextarea = document.createElement("textarea");
              variantTextarea.rows = 1;
              variantTextarea.value = entry.value || "";
              variantTextarea.addEventListener("change", async (event) => {
                if (!activeKey) {
                  setStatus(
                    "Set a key before saving plural translations",
                    true,
                  );
                  variantTextarea.value = entry.value || "";
                  return;
                }
                const updates = { plural: {} };
                updates.plural[caseKey] = { value: event.target.value };
                try {
                  await upsertTranslation(
                    {
                      key: activeKey,
                      language: state.currentLanguage,
                      variations: updates,
                    },
                    `Plural '${caseKey}' saved`,
                  );
                  if (isDraft) {
                    dropDraft(item.__draftId);
                    captureScrollPosition();
                    await fetchTranslations(
                      document.getElementById("search").value,
                    );
                  } else {
                    entry.value = event.target.value;
                  }
                } catch (error) {
                  setStatus(error.message, true);
                  variantTextarea.value = entry.value || "";
                }
              });
              rowContent.appendChild(variantTextarea);
              requestAnimationFrame(() => initAutoResize(variantTextarea));

              const deleteVariant = document.createElement("button");
              deleteVariant.type = "button";
              deleteVariant.className = "icon-button danger";
              deleteVariant.title = `Remove ${caseKey} plural`;
              deleteVariant.textContent = "×";
              deleteVariant.addEventListener("click", async () => {
                if (!activeKey) {
                  setStatus("Set a key before removing plural forms", true);
                  return;
                }
                const updates = { plural: {} };
                updates.plural[caseKey] = { value: null };
                try {
                  await upsertTranslation(
                    {
                      key: activeKey,
                      language: state.currentLanguage,
                      variations: updates,
                    },
                    `Plural '${caseKey}' removed`,
                  );
                  captureScrollPosition();
                  await fetchTranslations(
                    document.getElementById("search").value,
                  );
                } catch (error) {
                  setStatus(error.message, true);
                }
              });
              rowContent.appendChild(deleteVariant);

              row.appendChild(rowContent);
              pluralList.appendChild(row);
            });

            translationDetails.appendChild(pluralList);
            translationDetailsHasContent = true;
          }

          // Display device variations
          if (deviceKeys.length) {
            const deviceList = document.createElement("div");
            deviceList.className = "plural-list"; // Reuse plural styling

            deviceKeys.forEach((caseKey) => {
              const entry = deviceVariations[caseKey] || {};
              const row = document.createElement("div");
              row.className = "plural-row";

              const label = document.createElement("label");
              label.textContent = `device: ${getCaseLabel("device", caseKey)}`;
              row.appendChild(label);

              const rowContent = document.createElement("div");
              rowContent.className = "plural-row-content";

              const variantTextarea = document.createElement("textarea");
              variantTextarea.rows = 1;
              variantTextarea.value = entry.value || "";
              variantTextarea.addEventListener("change", async (event) => {
                if (!activeKey) {
                  setStatus(
                    "Set a key before saving device translations",
                    true,
                  );
                  variantTextarea.value = entry.value || "";
                  return;
                }
                const updates = { device: {} };
                updates.device[caseKey] = { value: event.target.value };
                try {
                  await upsertTranslation(
                    {
                      key: activeKey,
                      language: state.currentLanguage,
                      variations: updates,
                    },
                    `Device '${getCaseLabel("device", caseKey)}' saved`,
                  );
                  if (isDraft) {
                    dropDraft(item.__draftId);
                    captureScrollPosition();
                    await fetchTranslations(
                      document.getElementById("search").value,
                    );
                  } else {
                    entry.value = event.target.value;
                  }
                } catch (error) {
                  setStatus(error.message, true);
                  variantTextarea.value = entry.value || "";
                }
              });
              rowContent.appendChild(variantTextarea);
              requestAnimationFrame(() => initAutoResize(variantTextarea));

              const deleteVariant = document.createElement("button");
              deleteVariant.type = "button";
              deleteVariant.className = "icon-button danger";
              deleteVariant.title = `Remove ${getCaseLabel("device", caseKey)} device`;
              deleteVariant.textContent = "×";
              deleteVariant.addEventListener("click", async () => {
                if (!activeKey) {
                  setStatus("Set a key before removing device forms", true);
                  return;
                }
                const updates = { device: {} };
                updates.device[caseKey] = { value: null };
                try {
                  await upsertTranslation(
                    {
                      key: activeKey,
                      language: state.currentLanguage,
                      variations: updates,
                    },
                    `Device '${getCaseLabel("device", caseKey)}' removed`,
                  );
                  captureScrollPosition();
                  await fetchTranslations(
                    document.getElementById("search").value,
                  );
                } catch (error) {
                  setStatus(error.message, true);
                }
              });
              rowContent.appendChild(deleteVariant);

              row.appendChild(rowContent);
              deviceList.appendChild(row);
            });

            translationDetails.appendChild(deviceList);
            translationDetailsHasContent = true;
          }

          const availablePluralCases = PLURAL_CASES.filter(
            (caseKey) => !pluralKeys.includes(caseKey),
          );
          const availableDeviceCases = DEVICE_CASES.filter(
            (caseKey) => !deviceKeys.includes(caseKey),
          );
          const keyToolsContainer = keyDetails.querySelector(".key-tools");

          // Show "+ Plural" button only if there are no device variations
          if (
            keyToolsContainer &&
            availablePluralCases.length &&
            deviceKeys.length === 0
          ) {
            const addPluralBtn = document.createElement("button");
            addPluralBtn.type = "button";
            addPluralBtn.className = "icon-button";
            addPluralBtn.title = "Add plural form";
            addPluralBtn.textContent = "＋ Plural";

            const picker = document.createElement("div");
            picker.className = "plural-picker hidden";

            addPluralBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              if (!activeKey) {
                setStatus("Set a key before adding plural forms", true);
                return;
              }
              picker.classList.toggle("hidden");
            });

            document.addEventListener("click", (event) => {
              if (!keyTools.contains(event.target)) {
                picker.classList.add("hidden");
              }
            });

            availablePluralCases.forEach((caseKey) => {
              const optionBtn = document.createElement("button");
              optionBtn.type = "button";
              optionBtn.className = "plural-option";
              optionBtn.textContent = getCaseLabel("plural", caseKey);
              optionBtn.addEventListener("click", async () => {
                if (!activeKey) {
                  setStatus("Set a key before adding plural forms", true);
                  picker.classList.add("hidden");
                  return;
                }
                const updates = { plural: {} };
                updates.plural[caseKey] = { value: "", state: "new" };
                try {
                  await upsertTranslation(
                    {
                      key: activeKey,
                      language: state.currentLanguage,
                      variations: updates,
                    },
                    `Plural '${caseKey}' added`,
                  );
                  picker.classList.add("hidden");
                  captureScrollPosition();
                  await fetchTranslations(
                    document.getElementById("search").value,
                  );
                } catch (error) {
                  setStatus(error.message, true);
                }
              });
              picker.appendChild(optionBtn);
            });

            keyToolsContainer.appendChild(addPluralBtn);
            keyToolsContainer.appendChild(picker);
          }

          // Show "+ Device" button only if there are no plural variations
          if (
            keyToolsContainer &&
            availableDeviceCases.length &&
            pluralKeys.length === 0
          ) {
            const addDeviceBtn = document.createElement("button");
            addDeviceBtn.type = "button";
            addDeviceBtn.className = "icon-button";
            addDeviceBtn.title = "Add device form";
            addDeviceBtn.textContent = "＋ Device";

            const picker = document.createElement("div");
            picker.className = "plural-picker hidden"; // Reuse plural picker styling

            addDeviceBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              if (!activeKey) {
                setStatus("Set a key before adding device forms", true);
                return;
              }
              picker.classList.toggle("hidden");
            });

            document.addEventListener("click", (event) => {
              if (!keyTools.contains(event.target)) {
                picker.classList.add("hidden");
              }
            });

            availableDeviceCases.forEach((caseKey) => {
              const optionBtn = document.createElement("button");
              optionBtn.type = "button";
              optionBtn.className = "plural-option"; // Reuse plural option styling
              optionBtn.textContent = getCaseLabel("device", caseKey);
              optionBtn.addEventListener("click", async () => {
                if (!activeKey) {
                  setStatus("Set a key before adding device forms", true);
                  picker.classList.add("hidden");
                  return;
                }
                const updates = { device: {} };
                updates.device[caseKey] = { value: "", state: "new" };
                try {
                  await upsertTranslation(
                    {
                      key: activeKey,
                      language: state.currentLanguage,
                      variations: updates,
                    },
                    `Device '${getCaseLabel("device", caseKey)}' added`,
                  );
                  picker.classList.add("hidden");
                  captureScrollPosition();
                  await fetchTranslations(
                    document.getElementById("search").value,
                  );
                } catch (error) {
                  setStatus(error.message, true);
                }
              });
              picker.appendChild(optionBtn);
            });

            keyToolsContainer.appendChild(addDeviceBtn);
            keyToolsContainer.appendChild(picker);
          }

          const addSubstitutionBtn = document.createElement("button");
          addSubstitutionBtn.type = "button";
          addSubstitutionBtn.className = "icon-button add-substitution-button";
          addSubstitutionBtn.textContent = "＋ Substitution";
          addSubstitutionBtn.title = "Add substitution";
          addSubstitutionBtn.addEventListener("click", async () => {
            if (!state.currentLanguage) {
              setStatus("Select a language before adding substitutions", true);
              return;
            }
            if (!activeKey) {
              setStatus("Set a key before adding substitutions", true);
              return;
            }
            const newKey = prompt("Enter substitution key");
            if (!newKey) {
              return;
            }
            try {
              await updateSubstitution(
                activeKey,
                newKey,
                { value: "", state: "new" },
                "Substitution added",
              );
              captureScrollPosition();
              await fetchTranslations(
                document.getElementById("search").value || "",
              );
            } catch (error) {
              setStatus(error.message, true);
            }
          });
          if (keyToolsContainer) {
            keyToolsContainer.appendChild(addSubstitutionBtn);
          }

          const substitutionsAdded = renderSubstitutions({
            container: translationDetails,
            translation,
            activeKey,
            isDraft,
          });
          if (substitutionsAdded) {
            translationDetailsHasContent = true;
          }

          if (translationDetailsHasContent) {
            translationWrapper.appendChild(translationDetails);
          }

          translationCell.appendChild(translationWrapper);
          tr.appendChild(translationCell);

          applyRowStateStyles(tr, translation.state);
          syncExpansion();

          tbody.appendChild(tr);
        });

        Array.from(expandedRows).forEach((id) => {
          if (!seenRowIds.has(id)) {
            expandedRows.delete(id);
          }
        });

        restoreScrollPositionIfNeeded();
      }

      async function updateTranslationState(key, language, nextState) {
        if (!language) {
          throw new Error("Select a language before updating state");
        }
        if (SAMPLE_MODE) {
          const target = sampleStore.items.find((item) => item.key === key);
          if (!target) {
            throw new Error("Key not found in sample data");
          }
          const translation = target.translations[language] || {};
          translation.state = nextState;
          target.translations[language] = translation;
          setStatus("Translation state updated");
          return;
        }

        await upsertTranslation(
          { key, language, state: nextState },
          "Translation state updated",
        );
      }

      async function updateExtractionState(key, extractionState) {
        if (SAMPLE_MODE) {
          const target = sampleStore.items.find((item) => item.key === key);
          if (!target) {
            throw new Error("Key not found in sample data");
          }
          target.extractionState = extractionState || null;
          setStatus("Extraction state updated");
          return;
        }
        if (!state.currentPath) {
          throw new Error("Select a file before updating extraction state");
        }
        const res = await fetch("/api/extraction-state", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            key,
            extractionState: extractionState,
            path: state.currentPath,
          }),
        });
        if (!res.ok) {
          let message = `Failed to update extraction state (${res.status})`;
          try {
            const err = await res.json();
            if (err?.error) {
              message = err.error;
            }
          } catch (_) {
            // ignore
          }
          throw new Error(message);
        }
        setStatus("Extraction state updated");
      }

      async function updateShouldTranslate(key, shouldTranslate) {
        if (SAMPLE_MODE) {
          const target = sampleStore.items.find((item) => item.key === key);
          if (!target) {
            throw new Error("Key not found in sample data");
          }
          target.shouldTranslate = shouldTranslate || null;
          setStatus("Should translate updated");
          return;
        }
        if (!state.currentPath) {
          throw new Error("Select a file before updating should translate");
        }
        const res = await fetch("/api/should-translate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            key,
            shouldTranslate: shouldTranslate,
            path: state.currentPath,
          }),
        });
        if (!res.ok) {
          let message = `Failed to update should translate (${res.status})`;
          try {
            const err = await res.json();
            if (err?.error) {
              message = err.error;
            }
          } catch (_) {
            // ignore
          }
          throw new Error(message);
        }
        setStatus("Should translate updated");
      }

      function mergeSubstitution(existing, patch) {
        const result = { ...existing };

        if (result.substitutions !== undefined) {
          delete result.substitutions;
        }

        if (patch === null) {
          return null;
        }
        if (patch.value !== undefined) {
          result.value = patch.value;
        }
        if (patch.state !== undefined) {
          result.state = patch.state;
        }
        if (patch.argNum !== undefined) {
          result.argNum = patch.argNum;
        }
        if (patch.formatSpecifier !== undefined) {
          result.formatSpecifier = patch.formatSpecifier;
        }
        if (patch.variations !== undefined) {
          result.variations = result.variations || {};
          Object.entries(patch.variations).forEach(([selector, cases]) => {
            result.variations[selector] = {
              ...(result.variations[selector] || {}),
              ...cases,
            };
          });
        }
        if (pruneSubstitutionInPlace(result)) {
          return null;
        }
        return result;
      }

      async function updateSubstitution(
        key,
        substitutionKey,
        patch,
        successMessage,
      ) {
        if (!state.currentLanguage) {
          throw new Error("Select a language before editing substitutions");
        }
        if (SAMPLE_MODE) {
          const target = sampleStore.items.find((item) => item.key === key);
          if (!target) {
            throw new Error("Key not found in sample data");
          }
          const translation = target.translations[state.currentLanguage] || {};
          translation.substitutions = translation.substitutions || {};
          if (patch === null) {
            delete translation.substitutions[substitutionKey];
          } else {
            const merged = mergeSubstitution(
              translation.substitutions[substitutionKey] || {},
              patch,
            );
            if (merged === null) {
              delete translation.substitutions[substitutionKey];
            } else {
              translation.substitutions[substitutionKey] = merged;
            }
          }
          if (
            translation.substitutions &&
            Object.keys(translation.substitutions).length === 0
          ) {
            delete translation.substitutions;
          }
          if (pruneTranslationInPlace(translation)) {
            delete target.translations[state.currentLanguage];
          } else {
            target.translations[state.currentLanguage] = translation;
          }
          setStatus(successMessage);
          return;
        }

        captureScrollPosition();
        await upsertTranslation(
          {
            key,
            language: state.currentLanguage,
            substitutions: {
              [substitutionKey]: patch,
            },
          },
          successMessage,
        );
      }

      function renderSubstitutions({
        container,
        translation,
        activeKey,
        isDraft,
      }) {
        if (!activeKey || isDraft) {
          return false;
        }
        const substitutions = translation.substitutions || {};
        const subKeys = Object.keys(substitutions);
        if (!subKeys.length) {
          return false;
        }

        const panel = document.createElement("details");
        panel.className = "substitutions-panel";
        panel.open = subKeys.length <= 3;

        const summary = document.createElement("summary");
        summary.className = "substitutions-summary";
        summary.textContent =
          subKeys.length === 1
            ? "Substitution"
            : `Substitutions (${subKeys.length})`;
        panel.appendChild(summary);

        const section = document.createElement("div");
        section.className = "substitutions-section";
        panel.appendChild(section);

        subKeys.forEach((subKey) => {
          const substitution = substitutions[subKey] || {};
          const block = document.createElement("div");
          block.className = "substitution-block";

          const subHeader = document.createElement("div");
          subHeader.className = "substitution-header";

          const name = document.createElement("strong");
          name.textContent = subKey;
          subHeader.appendChild(name);

          const headerActions = document.createElement("div");
          headerActions.className = "substitution-actions";

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "icon-button danger";
          removeBtn.textContent = "×";
          removeBtn.title = "Remove substitution";
          removeBtn.addEventListener("click", async () => {
            if (!activeKey) {
              return;
            }
            try {
              await updateSubstitution(
                activeKey,
                subKey,
                null,
                "Substitution removed",
              );
              captureScrollPosition();
              await fetchTranslations(
                document.getElementById("search").value || "",
              );
            } catch (error) {
              setStatus(error.message, true);
            }
          });
          headerActions.appendChild(removeBtn);
          subHeader.appendChild(headerActions);
          block.appendChild(subHeader);

          const fields = document.createElement("div");
          fields.className = "substitution-fields";

          // argNum field row
          const argNumRow = document.createElement("div");
          argNumRow.className = "substitution-field-row";
          const argNumLabel = document.createElement("label");
          argNumLabel.className = "substitution-field-label";
          argNumLabel.textContent = "Arg Number:";
          argNumRow.appendChild(argNumLabel);

          const argNumInput = document.createElement("input");
          argNumInput.type = "text";
          argNumInput.placeholder = "Auto-calculated";
          argNumInput.readOnly = true;
          argNumInput.style.background = "#f8f8f8";
          argNumInput.style.color = "#666";
          if (
            substitution.argNum !== undefined &&
            substitution.argNum !== null
          ) {
            argNumInput.value = substitution.argNum;
          } else {
            argNumInput.value = "Auto";
          }
          argNumRow.appendChild(argNumInput);
          fields.appendChild(argNumRow);

          // formatSpecifier field row
          const formatRow = document.createElement("div");
          formatRow.className = "substitution-field-row";
          const formatLabel = document.createElement("label");
          formatLabel.className = "substitution-field-label";
          formatLabel.textContent = "Format:";
          formatRow.appendChild(formatLabel);

          const formatSelect = document.createElement("select");
          formatSelect.className = "format-specifier-dropdown";

          const formatOptions = [
            { value: "", label: "None" },
            { value: "@", label: "@ - Object/String" },
            { value: "ld", label: "ld - Long Integer" },
            { value: "lld", label: "lld - Long Long Integer" },
            { value: "llu", label: "llu - Long Long Unsigned" },
            { value: "lf", label: "lf - Long Float/Double" },
          ];

          formatOptions.forEach((option) => {
            const optionElem = document.createElement("option");
            optionElem.value = option.value;
            optionElem.textContent = option.label;
            if ((substitution.formatSpecifier || "") === option.value) {
              optionElem.selected = true;
            }
            formatSelect.appendChild(optionElem);
          });

          formatSelect.addEventListener("change", async (event) => {
            const value = event.target.value || null;
            try {
              await updateSubstitution(
                activeKey,
                subKey,
                { formatSpecifier: value },
                "Format specifier saved",
              );
            } catch (error) {
              setStatus(error.message, true);
              formatSelect.value = substitution.formatSpecifier || "";
            }
          });
          formatRow.appendChild(formatSelect);
          fields.appendChild(formatRow);

          // State field row
          const stateRow = document.createElement("div");
          stateRow.className = "substitution-field-row";
          const stateLabel = document.createElement("label");
          stateLabel.className = "substitution-field-label";
          stateLabel.textContent = "State:";
          stateRow.appendChild(stateLabel);

          const stateDropdown = document.createElement("select");
          stateDropdown.className = "state-dropdown";
          TRANSLATION_STATES.forEach((option) => {
            const normalized = option || "";
            const optionElem = document.createElement("option");
            optionElem.value = normalized;
            optionElem.textContent = translationStateLabel(normalized);
            if ((substitution.state || "") === normalized) {
              optionElem.selected = true;
            }
            stateDropdown.appendChild(optionElem);
          });
          stateDropdown.addEventListener("change", async (event) => {
            const previous = substitution.state || "";
            const next = event.target.value || null;
            try {
              await updateSubstitution(
                activeKey,
                subKey,
                { state: next },
                "Substitution state saved",
              );
              substitution.state = next;
            } catch (error) {
              setStatus(error.message, true);
              substitution.state = previous ? previous : null;
              stateDropdown.value = previous;
            }
          });
          stateRow.appendChild(stateDropdown);
          fields.appendChild(stateRow);

          // Value field row
          const valueRow = document.createElement("div");
          valueRow.className = "substitution-field-row";
          const valueLabel = document.createElement("label");
          valueLabel.className = "substitution-field-label";
          valueLabel.textContent = "Value:";
          valueRow.appendChild(valueLabel);

          const valueTextarea = document.createElement("textarea");
          valueTextarea.rows = 1;
          valueTextarea.value = substitution.value || "";
          valueTextarea.addEventListener("change", async (event) => {
            try {
              await updateSubstitution(
                activeKey,
                subKey,
                { value: event.target.value },
                "Substitution value saved",
              );
            } catch (error) {
              setStatus(error.message, true);
              valueTextarea.value = substitution.value || "";
            }
          });
          valueRow.appendChild(valueTextarea);
          fields.appendChild(valueRow);
          requestAnimationFrame(() => initAutoResize(valueTextarea));

          block.appendChild(fields);

          renderSubstitutionVariations({
            container: block,
            substitution,
            activeKey,
            subKey,
          });

          section.appendChild(block);
        });

        container.appendChild(panel);
        return true;
      }

      function renderSubstitutionVariations({
        container,
        substitution,
        activeKey,
        subKey,
      }) {
        const variations = substitution.variations || {};
        const selectors = Object.keys(variations);
        const wrapper = document.createElement("div");
        wrapper.className = "variation-section";
        let hasContent = false;

        const attachCasePicker = (trigger, selector, existingCases) => {
          const available = availableVariationCases(selector, existingCases);
          if (!available.length) {
            return null;
          }
          const picker = document.createElement("div");
          picker.className = "variation-picker hidden";

          available.forEach((caseKey) => {
            const optionBtn = document.createElement("button");
            optionBtn.type = "button";
            optionBtn.className = "variation-option";
            optionBtn.textContent = getCaseLabel(selector, caseKey);
            optionBtn.addEventListener("click", async () => {
              if (!activeKey) {
                picker.classList.add("hidden");
                return;
              }
              try {
                await updateSubstitution(
                  activeKey,
                  subKey,
                  {
                    variations: {
                      [selector]: {
                        [caseKey]: { value: "", state: "new" },
                      },
                    },
                  },
                  `Added ${selector} case '${caseKey}'`,
                );
                picker.classList.add("hidden");
                captureScrollPosition();
                await fetchTranslations(
                  document.getElementById("search").value || "",
                );
              } catch (error) {
                setStatus(error.message, true);
              }
            });
            picker.appendChild(optionBtn);
          });

          trigger.addEventListener("click", (event) => {
            event.stopPropagation();
            picker.classList.toggle("hidden");
          });

          document.addEventListener("click", (event) => {
            if (!trigger.contains(event.target)) {
              picker.classList.add("hidden");
            }
          });

          return picker;
        };

        selectors.forEach((selector) => {
          const cases = variations[selector] || {};
          const caseKeys = Object.keys(cases);
          const variationBlock = document.createElement("div");
          variationBlock.className = "variation-block";

          const header = document.createElement("div");
          header.className = "variation-header";
          const heading = document.createElement("span");
          heading.className = "meta-label";
          heading.textContent = `${variationLabel(selector)} variations`;
          header.appendChild(heading);

          const actions = document.createElement("div");
          actions.className = "variation-actions";
          const addCaseBtn = document.createElement("button");
          addCaseBtn.type = "button";
          addCaseBtn.className = "icon-button";
          addCaseBtn.textContent = `＋ ${variationLabel(selector)}`;
          const actionItem = document.createElement("div");
          actionItem.className = "variation-action";
          actionItem.appendChild(addCaseBtn);

          const picker = attachCasePicker(addCaseBtn, selector, caseKeys);
          if (picker) {
            actionItem.appendChild(picker);
          } else {
            addCaseBtn.addEventListener("click", async () => {
              const caseName = prompt(`Enter ${selector} case name to add`);
              const normalizedCase = (caseName || "").trim();
              if (!normalizedCase) {
                return;
              }
              try {
                await updateSubstitution(
                  activeKey,
                  subKey,
                  {
                    variations: {
                      [selector]: {
                        [normalizedCase]: { value: "", state: "new" },
                      },
                    },
                  },
                  `Added ${selector} case '${normalizedCase}'`,
                );
                captureScrollPosition();
                await fetchTranslations(
                  document.getElementById("search").value || "",
                );
              } catch (error) {
                setStatus(error.message, true);
              }
            });
          }
          if (actionItem.childElementCount) {
            actions.appendChild(actionItem);
            variationBlock.appendChild(actions);
          }

          const casesContainer = document.createElement("div");
          casesContainer.className = "variation-cases";

          caseKeys.forEach((caseKey) => {
            const entry = cases[caseKey] || {};
            const caseRow = document.createElement("div");
            caseRow.className = "variation-row";

            const label = document.createElement("span");
            label.className = "variation-case-label";
            label.textContent = getCaseLabel(selector, caseKey);
            caseRow.appendChild(label);

            const rowContent = document.createElement("div");
            rowContent.className = "variation-row-content";

            const input = document.createElement("textarea");
            input.rows = 1;
            input.value = entry.value || "";
            input.addEventListener("change", async (event) => {
              try {
                await updateSubstitution(
                  activeKey,
                  subKey,
                  {
                    variations: {
                      [selector]: {
                        [caseKey]: { value: event.target.value },
                      },
                    },
                  },
                  `${variationLabel(selector)} '${caseKey}' saved`,
                );
              } catch (error) {
                setStatus(error.message, true);
                input.value = entry.value || "";
              }
            });
            rowContent.appendChild(input);
            requestAnimationFrame(() => initAutoResize(input));

            const deleteBtn = document.createElement("button");
            deleteBtn.type = "button";
            deleteBtn.className = "icon-button danger";
            deleteBtn.textContent = "×";
            deleteBtn.title = `Remove ${selector} case ${caseKey}`;
            deleteBtn.addEventListener("click", async () => {
              try {
                await updateSubstitution(
                  activeKey,
                  subKey,
                  {
                    variations: {
                      [selector]: {
                        [caseKey]: { value: null },
                      },
                    },
                  },
                  `${variationLabel(selector)} '${caseKey}' removed`,
                );
                captureScrollPosition();
                await fetchTranslations(
                  document.getElementById("search").value || "",
                );
              } catch (error) {
                setStatus(error.message, true);
              }
            });
            rowContent.appendChild(deleteBtn);

            caseRow.appendChild(rowContent);
            casesContainer.appendChild(caseRow);
          });

          variationBlock.appendChild(casesContainer);
          wrapper.appendChild(variationBlock);
          hasContent = true;
        });

        const addRow = document.createElement("div");
        addRow.className = "variation-add-row";
        Object.keys(VARIATION_SELECTORS).forEach((selector) => {
          const existingCases = Object.keys(variations[selector] || {});
          const addBtn = document.createElement("button");
          addBtn.type = "button";
          addBtn.className = "icon-button";
          addBtn.textContent = `＋ ${variationLabel(selector)}`;
          const addWrapper = document.createElement("div");
          addWrapper.className = "variation-action";
          addWrapper.appendChild(addBtn);
          const picker = attachCasePicker(addBtn, selector, existingCases);
          if (picker) {
            addWrapper.appendChild(picker);
          } else {
            addBtn.addEventListener("click", async () => {
              const caseName = prompt(`Enter ${selector} case name to add`);
              const normalizedCase = (caseName || "").trim();
              if (!normalizedCase) {
                return;
              }
              try {
                await updateSubstitution(
                  activeKey,
                  subKey,
                  {
                    variations: {
                      [selector]: {
                        [normalizedCase]: { value: "", state: "new" },
                      },
                    },
                  },
                  `Added ${selector} case '${normalizedCase}'`,
                );
                captureScrollPosition();
                await fetchTranslations(
                  document.getElementById("search").value || "",
                );
              } catch (error) {
                setStatus(error.message, true);
              }
            });
          }
          addRow.appendChild(addWrapper);
        });

        if (addRow.childElementCount) {
          wrapper.appendChild(addRow);
          hasContent = true;
        }

        if (!hasContent) {
          return;
        }

        container.appendChild(wrapper);
      }

      async function upsertTranslation(
        payload,
        successMessage = "Translation saved",
      ) {
        const { key, language } = payload;
        if (!language) {
          throw new Error("Select a language before saving");
        }
        if (SAMPLE_MODE) {
          if (!key) {
            throw new Error("Set a key before saving a translation");
          }
          let target = sampleStore.items.find((item) => item.key === key);
          if (!target) {
            target = { key, comment: "", translations: {} };
            sampleStore.items.push(target);
          }
          const translation = target.translations[language] || {};
          if (payload.value !== undefined) {
            translation.value = payload.value;
          }
          if (payload.state !== undefined) {
            translation.state = payload.state;
          }
          if (payload.variations !== undefined) {
            translation.variations = translation.variations || {};
            Object.entries(payload.variations).forEach(([selector, cases]) => {
              translation.variations[selector] = {
                ...(translation.variations[selector] || {}),
                ...cases,
              };
            });
          }
          if (payload.substitutions !== undefined) {
            translation.substitutions = translation.substitutions || {};
            Object.entries(payload.substitutions).forEach(([name, patch]) => {
              if (patch === null) {
                delete translation.substitutions[name];
                return;
              }
              const merged = mergeSubstitution(
                translation.substitutions[name] || {},
                patch,
              );
              if (merged === null) {
                delete translation.substitutions[name];
              } else {
                translation.substitutions[name] = merged;
              }
            });
          }

          if (
            translation.substitutions &&
            Object.keys(translation.substitutions).length === 0
          ) {
            delete translation.substitutions;
          }

          if (pruneTranslationInPlace(translation)) {
            delete target.translations[language];
          } else {
            target.translations[language] = translation;
          }
          setStatus(successMessage);
          return;
        }

        const body = { key, language };
        if (!state.currentPath) {
          throw new Error("Select a file before saving a translation");
        }
        body.path = state.currentPath;
        if (payload.value !== undefined) {
          body.value = payload.value;
        }
        if (payload.state !== undefined) {
          body.state = payload.state;
        }
        if (payload.variations !== undefined) {
          body.variations = payload.variations;
        }
        if (payload.substitutions !== undefined) {
          body.substitutions = payload.substitutions;
        }

        const res = await fetch("/api/translations", {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });

        if (!res.ok) {
          let message = `Failed to save translation (${res.status})`;
          try {
            const errorBody = await res.json();
            if (errorBody?.error) {
              message = errorBody.error;
            }
          } catch (_) {
            // ignore JSON parse errors
          }
          throw new Error(message);
        }

        setStatus(successMessage);
      }

      async function renameKey(oldKey, newKey) {
        if (SAMPLE_MODE) {
          if (
            sampleStore.items.some(
              (item) => item.key === newKey && item.key !== oldKey,
            )
          ) {
            throw new Error("A key with that name already exists");
          }
          const target = sampleStore.items.find((item) => item.key === oldKey);
          if (!target) {
            throw new Error("Key not found");
          }
          target.key = newKey;
          return;
        }
        if (!state.currentPath) {
          throw new Error("Select a file before renaming keys");
        }
        const res = await fetch(`/api/keys/${encodeURIComponent(oldKey)}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ new_key: newKey, path: state.currentPath }),
        });
        if (!res.ok) {
          let message = `Failed to rename key (${res.status})`;
          try {
            const errorBody = await res.json();
            if (errorBody?.error) {
              message = errorBody.error;
            }
          } catch (_) {
            // ignore JSON parse errors
          }
          throw new Error(message);
        }
      }

      function setStatus(message, isError = false) {
        // Legacy status bar update for backward compatibility
        const status = document.getElementById("status");
        status.textContent = "";
        status.className = "status";

        // Show toast notification
        if (message) {
          showToast(message, isError);
        }
      }

      function showToast(message, isError = false) {
        const container = document.getElementById("toast-container");
        const toast = document.createElement("div");
        toast.className = `toast ${isError ? "error" : "success"}`;
        toast.textContent = message;

        container.appendChild(toast);

        // Auto-dismiss after 3.5 seconds
        setTimeout(() => {
          toast.classList.add("hiding");
          setTimeout(() => {
            container.removeChild(toast);
          }, 300);
        }, 3500);
      }

      document
        .getElementById("file-select")
        .addEventListener("change", async (event) => {
          const nextPath = event.target.value || null;
          if (SAMPLE_MODE) {
            return;
          }
          if (!nextPath) {
            state.currentPath = null;
            state.languages = [];
            state.items = [];
            state.drafts = [];
            renderLanguageControls();
            renderTable();
            updateControlState();
            return;
          }
          if (state.currentPath === nextPath) {
            return;
          }
          state.currentPath = nextPath;
          state.drafts = [];
          await fetchLanguages();
          const query = document.getElementById("search").value || "";
          await fetchTranslations(query);
        });

      document
        .getElementById("language-select")
        .addEventListener("change", (event) => {
          const next = event.target.value;
          if (!next || state.currentLanguage === next) {
            return;
          }
          state.currentLanguage = next;
          document.getElementById("language-header").textContent =
            translationHeaderText();
          renderTable();
        });

      document
        .getElementById("reference-select")
        .addEventListener("change", (event) => {
          const next = event.target.value || null;
          if (state.referenceLanguage === next) {
            return;
          }
          state.referenceLanguage = next;
          renderTable();
        });

      document.getElementById("search").addEventListener("input", (event) => {
        if (!state.currentPath && !SAMPLE_MODE) {
          return;
        }
        const query = event.target.value;
        fetchTranslations(query);
      });

      document
        .getElementById("add-translation")
        .addEventListener("click", () => {
          if (!state.currentLanguage) {
            setStatus("Select a language before adding translations", true);
            return;
          }
          if (!state.currentPath && !SAMPLE_MODE) {
            setStatus("Select a file before adding translations", true);
            return;
          }
          const draftId = `draft-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
          const draft = {
            __draft: true,
            __draftId: draftId,
            key: "",
            comment: "",
            extractionState: null,
            translations: {},
          };
          state.drafts.unshift(draft);
          expandedRows.add(draftId);
          renderTable();
          window.requestAnimationFrame(() => {
            const input = document.querySelector(
              `.key-input[data-draft="${draftId}"]`,
            );
            if (input) {
              input.focus();
            }
          });
        });

      (async function init() {
        await loadFiles();
      })();
    </script>
  </body>
</html>
