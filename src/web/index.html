<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>xcstrings Translations</title>
    <style>
      :root {
        color-scheme: light;
      }
      * {
        box-sizing: border-box;
      }
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue",
          Arial, sans-serif;
        margin: 0;
        background: #f6f6f7;
        color: #1c1c1e;
      }
      .hidden {
        display: none !important;
      }
      main {
        width: 100%;
        margin: 0;
        padding: 4rem 3vw 2.5rem;
      }
      header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        margin-bottom: 1rem;
      }
      h1 {
        font-size: 2rem;
        font-weight: 700;
        letter-spacing: -0.02em;
        margin: 0;
      }
      nav.nav-bar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 30;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 0.6rem;
        padding: 0.6rem 3vw;
        background: #fff;
        border-bottom: 1px solid #d6d6db;
      }
      .nav-title {
        font-size: 1.1rem;
        font-weight: 700;
        letter-spacing: -0.02em;
        margin: 0;
        margin-right: 1rem;
      }
      .nav-left,
      .nav-center,
      .nav-right {
        display: flex;
        align-items: center;
        gap: 0.6rem;
      }
      .nav-left {
        flex: 1 1 16rem;
        flex-wrap: wrap;
      }
      .nav-center {
        flex: 1 1 auto;
        justify-content: center;
        flex-wrap: wrap;
        gap: 0.4rem 0.75rem;
      }
      .nav-label {
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #6e6e73;
      }
      .nav-right {
        flex: 0 0 auto;
      }
      .reference-row {
        opacity: 0.75;
      }
      input:not(.search-field),
      textarea {
        font-family:
          "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas,
          "Courier New", monospace;
        font-size: 0.9rem;
        border-radius: 0;
        border: 1px solid #c7c7cd;
        background: #fff;
        padding: 0.4rem 0.6rem;
        transition:
          border-color 0.2s ease,
          background 0.2s ease;
        color: inherit;
      }
      textarea {
        resize: vertical;
        min-height: 2.6rem;
      }
      input:not(.search-field):focus,
      textarea:focus {
        outline: none;
        border-color: #0a84ff;
        background: #fff;
      }
      input.comment-input {
        font-size: 0.7rem;
        color: #666;
        border: 1px solid transparent;
        background: transparent;
        padding: 0.25rem 0.5rem;
        width: 100%;
        height: 1.6rem;
      }
      input.comment-input:hover {
        border-color: #d1d1d6;
        background: #fafafa;
      }
      input.comment-input:focus {
        border-color: #0a84ff;
        background: #fff;
      }
      input.comment-input::placeholder {
        color: #c7c7cc;
      }
      .search-field {
        flex: 1 1 auto;
        font: inherit;
        border-radius: 0;
        border: 1px solid #c7c7cd;
        background: #fff;
        padding: 0.4rem 0.6rem;
        transition: border-color 0.2s ease;
        color: inherit;
      }
      .search-field:focus {
        outline: none;
        border-color: #0a84ff;
        background: #fff;
      }
      button {
        font: inherit;
        border: 1px solid #1c1c1e;
        border-radius: 0;
        background: #1c1c1e;
        color: #fff;
        padding: 0.4rem 0.85rem;
        cursor: pointer;
        transition: background 0.15s ease;
      }
      button:hover {
        background: #0a84ff;
      }
      button:active {
        background: #005fcc;
      }
      button:disabled {
        background: #d6d6db;
        border-color: #d6d6db;
        color: #8e8e93;
        cursor: not-allowed;
      }
      button.secondary {
        border-color: #c7c7cd;
        background: #f0f0f2;
        color: #1c1c1e;
      }
      button.secondary:hover {
        background: #e0e0e5;
      }
      button.refresh-button {
        background: transparent;
        color: #1c1c1e;
        padding: 0.3rem 0.6rem;
        border-radius: 0;
        border-color: #c7c7cd;
      }
      button.refresh-button:hover {
        background: #e6e6ea;
      }
      button.add-button {
        padding: 0.3rem 0.6rem;
        border-radius: 0;
        font-size: 0.9rem;
        line-height: 1.2;
      }
      .file-select-group {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        min-width: 12rem;
      }
      .language-select-wrapper,
      .file-select-wrapper {
        position: relative;
      }
      .language-select,
      .file-select {
        appearance: none;
        background: #fff;
        color: #1c1c1e;
        padding: 0.4rem 2rem 0.4rem 0.6rem;
        border-radius: 0;
        border: 1px solid #c7c7cd;
        min-width: 11rem;
        cursor: pointer;
      }
      .file-select {
        min-width: 14rem;
      }
      .language-select:focus,
      .file-select:focus {
        outline: none;
        border-color: #0a84ff;
        background: #fff;
      }
      select:disabled,
      input:disabled,
      textarea:disabled {
        border-color: #e0e0e5;
        background: #f4f4f5;
        color: #8e8e93;
        cursor: not-allowed;
      }
      .language-select-wrapper::after,
      .file-select-wrapper::after {
        content: "\25BE";
        position: absolute;
        right: 0.9rem;
        top: 50%;
        transform: translateY(-50%);
        color: #6e6e73;
        pointer-events: none;
        font-size: 0.8rem;
      }
      .translation-row {
        transition: background 0.2s ease;
      }
      .translation-row:hover {
        background: rgba(245, 245, 247, 0.6);
      }
      .translation-row .key-tools {
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      .translation-row:hover .key-tools,
      .translation-row:focus-within .key-tools {
        opacity: 1;
      }
      .translation-row .key-tools .icon-button:nth-child(3) {
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      .translation-row:hover .key-tools .icon-button:nth-child(3),
      .translation-row:focus-within .key-tools .icon-button:nth-child(3) {
        opacity: 1;
      }
      .lang-button {
        background: #f0f0f2;
        border: 1px solid #c7c7cd;
        color: #1c1c1e;
        padding: 0.3rem 0.65rem;
        border-radius: 0;
        font-size: 0.85rem;
      }
      .lang-button:hover {
        background: #e0e0e5;
      }
      .lang-button.active {
        background: #1c1c1e;
        color: #fff;
      }
      .lang-button.subtle {
        background: #f6f6f7;
        color: #3a3a3c;
        border-color: #e0e0e5;
      }
      .lang-button.subtle.active {
        background: #4b4acf;
        color: #fff;
      }
      .language-row {
        display: flex;
        gap: 0.4rem;
        flex-wrap: wrap;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        margin-top: 1.5rem;
        background: #fff;
        border: 1px solid #d6d6db;
      }
      th,
      td {
        padding: 0.75rem 1rem;
        border-bottom: 1px solid #e0e0e5;
        vertical-align: top;
      }
      th {
        text-align: left;
        font-size: 0.78rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #6e6e73;
        background: #f6f6f7;
      }
      tr:last-child td {
        border-bottom: none;
      }
      .key-cell {
        width: 30%;
      }
      .translation-cell {
        width: auto;
      }
      .key-wrapper {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .key-header {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
      }
      .key-input {
        width: 100%;
        font-size: 1rem;
        font-weight: 600;
        padding: 0.35rem 0.25rem;
        height: 2.2rem;
      }
      .key-tools {
        display: flex;
        gap: 0.3rem;
        position: relative;
      }
      .icon-button {
        background: #f0f0f2;
        border: 1px solid #c7c7cd;
        color: #1c1c1e;
        padding: 0.2rem 0.45rem;
        border-radius: 0;
        min-width: unset;
        font-size: 0.85rem;
      }
      .icon-button:hover {
        background: #e0e0e5;
      }
      .icon-button.danger {
        background: #fff4f3;
        border-color: #ffb3ad;
        color: #d70015;
      }
      .icon-button.danger:hover {
        background: #ffd8d3;
      }
      .translation-wrapper {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .translation-input {
        min-height: 1.2rem;
        width: 100%;
        overflow: hidden;
        margin-bottom: 0.7rem;
      }
      .reference-line {
        display: flex;
        gap: 0.35rem;
        align-items: center;
        font-size: 0.8rem;
        color: #636366;
        flex-wrap: wrap;
        height: 1.6rem;
        padding: 0 0.5rem;
        background: #f9f9f9;
        border-left: 2px solid #e0e0e5;
      }
      .reference-line .reference-value {
        color: #1c1c1e;
        font-weight: 500;
        white-space: pre-wrap;
      }
      .status {
        margin-top: 1.2rem;
        color: #0a7;
        font-weight: 500;
        min-height: 1.2rem;
      }
      .status.error {
        color: #ff3b30;
      }
      .empty-placeholder {
        margin-top: 5rem;
        text-align: center;
        color: #6e6e73;
        font-size: 0.95rem;
      }
      .plural-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }
      .plural-row {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
        margin-bottom: 0.75rem;
      }
      .plural-row label {
        font-family:
          "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas,
          "Courier New", monospace;
        font-size: 0.8rem;
        color: #636366;
        padding: 0 0.5rem;
        background: #f9f9f9;
        border-left: 2px solid #e0e0e5;
        height: 1.2rem;
        display: flex;
        align-items: center;
      }
      .plural-row-content {
        display: flex;
        gap: 0.5rem;
        align-items: flex-start;
      }
      .plural-row textarea {
        flex: 1;
        resize: none;
        overflow: hidden;
        min-height: 2rem;
      }

      .plural-picker {
        position: absolute;
        top: 100%;
        left: 0;
        margin-top: 0.3rem;
        background: #fff;
        border: 1px solid #c7c7cd;
        padding: 0.5rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        z-index: 10;
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        max-width: 300px;
      }
      .plural-picker.hidden {
        display: none;
      }
      .plural-option {
        background: #f0f0f2;
        border: 1px solid #c7c7cd;
        color: #1c1c1e;
        padding: 0.3rem 0.6rem;
        border-radius: 0;
        font-size: 0.8rem;
        cursor: pointer;
        transition: background 0.2s ease;
      }
      .plural-option:hover {
        background: #e0e0e5;
      }
      .plural-empty {
        font-style: italic;
        color: #636366;
      }
      .plural-row .danger {
        width: 32px;
        height: 32px;
      }
      @media (max-width: 900px) {
        main {
          padding: 4.5rem 1.25rem 2.5rem;
        }
        nav.nav-bar {
          padding: 0.6rem 1.25rem;
          gap: 0.6rem;
        }
        .nav-left,
        .nav-center,
        .nav-right {
          flex: 1 1 100%;
          justify-content: center;
        }
        .nav-right {
          justify-content: flex-end;
        }
        .file-select-group {
          width: 100%;
        }
        table,
        thead,
        tbody,
        th,
        td,
        tr {
          display: block;
        }
        thead {
          display: none;
        }
        tr {
          margin-bottom: 1.25rem;
          border: 1px solid #d6d6db;
          border-radius: 0;
          padding: 0.75rem;
          background: #fff;
        }
        td {
          border: none;
          padding: 0.5rem 0;
        }
        .key-wrapper {
          flex-direction: column;
          gap: 0.4rem;
        }
      }
    </style>
  </head>
  <body>
    <nav class="nav-bar">
      <div class="nav-left">
        <div class="file-select-group">
          <label class="nav-label" for="file-select">File</label>
          <div class="file-select-wrapper">
            <select
              id="file-select"
              class="language-select file-select"
              title="Choose xcstrings file"
            ></select>
          </div>
        </div>
        <input
          type="text"
          id="search"
          class="search-field"
          placeholder="Search keys or translations"
        />
        <button class="refresh-button" id="refresh" title="Refresh list">
          Refresh
        </button>
      </div>
      <div class="nav-center">
        <label class="nav-label" for="language-select">Language</label>
        <div class="language-select-wrapper">
          <select
            id="language-select"
            class="language-select"
            title="Choose language"
          ></select>
        </div>
        <label class="nav-label" for="reference-select">Reference</label>
        <div class="language-select-wrapper">
          <select
            id="reference-select"
            class="language-select"
            title="Choose reference language"
          ></select>
        </div>
      </div>
      <div class="nav-right">
        <button class="add-button" id="add-translation" title="Add translation">
          ＋
        </button>
      </div>
    </nav>
    <main>
      <div id="empty-placeholder" class="empty-placeholder hidden">
        No .xcstrings files found. Add one to the project and refresh.
      </div>
      <div id="status" class="status"></div>
      <table id="translations-table">
        <thead>
          <tr>
            <th>Key</th>
            <th id="language-header">Translation</th>
          </tr>
        </thead>
        <tbody id="translations-body"></tbody>
      </table>
    </main>
    <script>
      const LANGUAGE_REGIONS = {
        en: "US",
        "en-gb": "GB",
        "en-us": "US",
        fr: "FR",
        de: "DE",
        es: "ES",
        it: "IT",
        ja: "JP",
        ko: "KR",
        zh: "CN",
        "zh-hans": "CN",
        "zh-hant": "CN",
        pt: "PT",
        "pt-br": "BR",
        ru: "RU",
        nl: "NL",
        sv: "SE",
        da: "DK",
        fi: "FI",
        nb: "NO",
        pl: "PL",
        cs: "CZ",
      };

      const LANGUAGE_LABELS = {
        en: "English",
        "en-gb": "English (UK)",
        "en-us": "English (US)",
        fr: "French",
        de: "German",
        es: "Spanish",
        it: "Italian",
        ja: "Japanese",
        ko: "Korean",
        zh: "Chinese",
        "zh-hans": "Chinese (Simplified)",
        "zh-hant": "Chinese (Traditional)",
        pt: "Portuguese",
        "pt-br": "Portuguese (Brazil)",
        ru: "Russian",
        nl: "Dutch",
        sv: "Swedish",
        da: "Danish",
        fi: "Finnish",
        nb: "Norwegian",
        pl: "Polish",
        cs: "Czech",
      };

      const PLURAL_CASES = ["zero", "one", "two", "few", "many", "other"];
      const state = {
        files: [],
        currentPath: null,
        languages: [],
        currentLanguage: null,
        referenceLanguage: null,
        items: [],
        drafts: [],
      };

      const SAMPLE_MODE = window.location.protocol === "file:";
      const SAMPLE_DATA = {
        languages: ["en", "fr", "de"],
        items: [
          {
            key: "welcome_title",
            comment: "Shown at the top of the dashboard",
            translations: {
              en: { value: "Welcome" },
              fr: { value: "Bienvenue" },
              de: { value: "Willkommen" },
            },
          },
          {
            key: "items_count",
            comment: "Displays the current number of tracked items",
            translations: {
              en: {
                value: "{count} item",
                variations: {
                  plural: {
                    one: { value: "{count} item" },
                    other: { value: "{count} items" },
                  },
                },
              },
              fr: {
                value: "{count} objet",
                variations: {
                  plural: {
                    one: { value: "{count} objet" },
                    other: { value: "{count} objets" },
                  },
                },
              },
              de: {
                value: "{count} Element",
                variations: {
                  plural: {
                    one: { value: "{count} Element" },
                    other: { value: "{count} Elemente" },
                  },
                },
              },
            },
          },
          {
            key: "sync_status",
            comment: "Banner shown while syncing with the localization service",
            translations: {
              en: { value: "Syncing latest content..." },
              fr: { value: "Synchronisation du contenu..." },
              de: { value: "Inhalte werden synchronisiert ..." },
            },
          },
        ],
      };
      const sampleStore = SAMPLE_MODE
        ? JSON.parse(JSON.stringify(SAMPLE_DATA))
        : null;

      function languageLabel(code) {
        if (!code) {
          return "";
        }
        const normalized = code.toLowerCase();
        if (LANGUAGE_LABELS[normalized]) {
          return LANGUAGE_LABELS[normalized];
        }
        const base = normalized.split(/[-_]/)[0];
        if (LANGUAGE_LABELS[base]) {
          return LANGUAGE_LABELS[base];
        }
        return code;
      }

      function formatLanguageDisplay(code) {
        if (!code) {
          return "";
        }
        return `${languageLabel(code)}(${code})`;
      }

      function translationHeaderText() {
        if (!state.currentLanguage) {
          return "Translation";
        }
        return `Translation — ${formatLanguageDisplay(state.currentLanguage)}`;
      }

      function dropDraft(draftId) {
        if (!draftId) {
          return;
        }
        state.drafts = state.drafts.filter(
          (draft) => draft.__draftId !== draftId,
        );
      }

      function renderLanguageControls() {
        const languageSelect = document.getElementById("language-select");
        const referenceSelect = document.getElementById("reference-select");
        languageSelect.innerHTML = "";
        referenceSelect.innerHTML = "";

        const englishCandidate =
          state.languages.find((lang) => lang.toLowerCase() === "en") ||
          state.languages.find((lang) => lang.toLowerCase().startsWith("en-"));

        if (
          !state.currentLanguage ||
          !state.languages.includes(state.currentLanguage)
        ) {
          state.currentLanguage =
            englishCandidate || state.languages[0] || null;
        }

        if (
          !state.referenceLanguage ||
          !state.languages.includes(state.referenceLanguage)
        ) {
          state.referenceLanguage =
            state.currentLanguage ||
            englishCandidate ||
            state.languages[0] ||
            null;
        }

        state.languages.forEach((lang) => {
          const option = document.createElement("option");
          option.value = lang;
          option.textContent = formatLanguageDisplay(lang);
          languageSelect.appendChild(option);

          const refOption = document.createElement("option");
          refOption.value = lang;
          refOption.textContent = formatLanguageDisplay(lang);
          referenceSelect.appendChild(refOption);
        });

        if (
          state.currentLanguage &&
          state.languages.includes(state.currentLanguage)
        ) {
          languageSelect.value = state.currentLanguage;
        } else if (state.languages.length) {
          state.currentLanguage = state.languages[0];
          languageSelect.value = state.currentLanguage;
        } else {
          languageSelect.value = "";
        }

        if (
          state.referenceLanguage &&
          state.languages.includes(state.referenceLanguage)
        ) {
          referenceSelect.value = state.referenceLanguage;
        } else if (state.languages.length) {
          state.referenceLanguage = state.currentLanguage || state.languages[0];
          referenceSelect.value = state.referenceLanguage;
        } else {
          referenceSelect.value = "";
        }

        document.getElementById("language-header").textContent =
          translationHeaderText();

        if (!state.languages.length) {
          state.currentLanguage = null;
          state.referenceLanguage = null;
        }

        updateControlState();
      }

      function updateControlState() {
        const hasFiles = SAMPLE_MODE || state.files.length > 0;
        const placeholder = document.getElementById("empty-placeholder");
        const table = document.getElementById("translations-table");
        const languageSelect = document.getElementById("language-select");
        const referenceSelect = document.getElementById("reference-select");
        const searchInput = document.getElementById("search");
        const addButton = document.getElementById("add-translation");

        placeholder.classList.toggle("hidden", hasFiles);
        table.classList.toggle("hidden", !hasFiles);

        languageSelect.disabled = !hasFiles || !state.languages.length;
        referenceSelect.disabled = !hasFiles || !state.languages.length;
        searchInput.disabled = !hasFiles && !SAMPLE_MODE;
        addButton.disabled = !hasFiles || !state.currentLanguage;
      }

      function renderFileSelector() {
        const select = document.getElementById("file-select");
        select.innerHTML = "";

        if (!state.files.length) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "No xcstrings files";
          select.appendChild(option);
          select.disabled = true;
          updateControlState();
          return;
        }

        if (
          state.currentPath &&
          !state.files.some((file) => file.path === state.currentPath)
        ) {
          state.currentPath = state.files[0].path;
        }

        state.files.forEach((file) => {
          const option = document.createElement("option");
          option.value = file.path;
          option.textContent = file.label || file.path;
          if (file.path === state.currentPath) {
            option.selected = true;
          }
          select.appendChild(option);
        });

        if (state.currentPath) {
          select.value = state.currentPath;
        }

        select.disabled = SAMPLE_MODE && state.files.length === 1;

        updateControlState();
      }

      async function fetchLanguages() {
        if (!state.currentPath && !SAMPLE_MODE) {
          state.languages = [];
          renderLanguageControls();
          return;
        }
        if (SAMPLE_MODE) {
          state.languages = sampleStore.languages.slice();
          renderLanguageControls();
          return;
        }
        try {
          const params = new URLSearchParams({ path: state.currentPath });
          const res = await fetch(`/api/languages?${params.toString()}`);
          if (!res.ok) {
            throw new Error(`Request failed with status ${res.status}`);
          }
          const data = await res.json();
          state.languages = data.languages || [];
        } catch (error) {
          console.error(error);
          state.languages = [];
          setStatus("Failed to load languages", true);
        }
        renderLanguageControls();
      }

      async function fetchTranslations(query = "") {
        if (!state.currentPath && !SAMPLE_MODE) {
          state.items = [];
          state.drafts = [];
          renderTable();
          return;
        }
        if (SAMPLE_MODE) {
          const normalized = query.trim().toLowerCase();
          const filtered = !normalized
            ? sampleStore.items
            : sampleStore.items.filter((item) => {
                const bucket = [];
                bucket.push(item.key || "");
                if (item.comment) {
                  bucket.push(item.comment);
                }
                sampleStore.languages.forEach((lang) => {
                  const translation = item.translations?.[lang];
                  if (!translation) {
                    return;
                  }
                  if (translation.value) {
                    bucket.push(translation.value);
                  }
                  const plural = translation.variations?.plural || {};
                  Object.values(plural).forEach((entry) => {
                    if (entry?.value) {
                      bucket.push(entry.value);
                    }
                  });
                });
                return bucket.join(" ").toLowerCase().includes(normalized);
              });

          state.items = filtered.map((item) =>
            JSON.parse(JSON.stringify(item)),
          );
        } else {
          try {
            const params = new URLSearchParams({ path: state.currentPath });
            const trimmed = query.trim();
            if (trimmed) {
              params.set("q", trimmed);
            }
            const res = await fetch(`/api/translations?${params.toString()}`);
            if (!res.ok) {
              throw new Error(`Request failed with status ${res.status}`);
            }
            const data = await res.json();
            state.items = data.items || [];
          } catch (error) {
            console.error(error);
            state.items = [];
            setStatus("Failed to load translations", true);
          }
        }

        state.drafts = state.drafts.filter((draft) => {
          if (!draft.key) {
            return true;
          }
          return !state.items.some((item) => item.key === draft.key);
        });
        renderTable();
      }

      async function loadFiles() {
        if (SAMPLE_MODE) {
          state.files = [{ path: "sample", label: "Sample data" }];
          state.currentPath = "sample";
          state.drafts = [];
          renderFileSelector();
          await fetchLanguages();
          await fetchTranslations(document.getElementById("search").value || "");
          return;
        }

        try {
          const res = await fetch("/api/files");
          if (!res.ok) {
            throw new Error(`Request failed with status ${res.status}`);
          }
          const data = await res.json();
          state.files = Array.isArray(data.files) ? data.files : [];

          if (state.files.length) {
            const preserved =
              state.currentPath &&
              state.files.some((file) => file.path === state.currentPath)
                ? state.currentPath
                : null;
            const defaultCandidate =
              data.default &&
              state.files.some((file) => file.path === data.default)
                ? data.default
                : null;
            state.currentPath =
              preserved || defaultCandidate || state.files[0].path;
          } else {
            state.currentPath = null;
          }

          state.drafts = [];
          renderFileSelector();

          if (state.currentPath) {
            await fetchLanguages();
            const query = document.getElementById("search").value || "";
            await fetchTranslations(query);
          } else {
            state.languages = [];
            state.items = [];
            renderLanguageControls();
            renderTable();
          }
        } catch (error) {
          console.error(error);
          setStatus("Failed to load xcstrings files", true);
          state.files = [];
          state.currentPath = null;
          state.languages = [];
          state.items = [];
          state.drafts = [];
          renderFileSelector();
          renderLanguageControls();
          renderTable();
        }
      }

      function referenceFor(item) {
        if (!state.referenceLanguage) {
          return null;
        }
        return item.translations[state.referenceLanguage] || null;
      }

      function autoResizeTextarea(textarea) {
        textarea.style.height = "auto";
        textarea.style.height = textarea.scrollHeight + "px";
      }

      function initAutoResize(textarea) {
        autoResizeTextarea(textarea);
        textarea.addEventListener("input", () => autoResizeTextarea(textarea));
      }

      function renderTable() {
        const tbody = document.getElementById("translations-body");
        tbody.innerHTML = "";
        const rows = [...state.drafts, ...state.items];
        rows.forEach((item) => {
          const isDraft = Boolean(item.__draft);
          if (!item.translations) {
            item.translations = {};
          }

          const tr = document.createElement("tr");
          tr.className = "translation-row";

          const keyCell = document.createElement("td");
          keyCell.className = "key-cell";
          const keyWrapper = document.createElement("div");
          keyWrapper.className = "key-wrapper";

          // Comment input first
          const commentInput = document.createElement("input");
          commentInput.type = "text";
          commentInput.className = "comment-input";
          commentInput.placeholder = "// comment";
          commentInput.value = item.comment || "";
          commentInput.addEventListener("change", async (event) => {
            if (!activeKey) {
              setStatus("Set a key before saving comments", true);
              commentInput.value = "";
              return;
            }
            if (isDraft) {
              setStatus("Save the translation before adding comments", true);
              commentInput.value = item.comment || "";
              return;
            }
          if (SAMPLE_MODE) {
            const target = sampleStore.items.find(
              (entry) => entry.key === activeKey,
            );
            if (!target) {
              setStatus("Save the translation before adding comments", true);
              commentInput.value = item.comment || "";
              return;
            }
            target.comment = event.target.value || "";
            item.comment = target.comment;
            setStatus("Comment saved");
            return;
          }
          if (!state.currentPath) {
            setStatus("Select a file before saving comments", true);
            commentInput.value = item.comment || "";
            return;
          }
          const res = await fetch("/api/comments", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              key: activeKey,
              path: state.currentPath,
              comment: event.target.value || null,
            }),
          });
            if (res.ok) {
              item.comment = event.target.value;
              setStatus("Comment saved");
            } else {
              setStatus("Failed to save comment", true);
            }
          });
          keyWrapper.appendChild(commentInput);

          const keyHeader = document.createElement("div");
          keyHeader.className = "key-header";

          const keyInput = document.createElement("input");
          keyInput.type = "text";
          keyInput.className = "key-input";
          keyInput.value = item.key || "";
          keyInput.placeholder = isDraft ? "New key" : "";
          keyInput.spellcheck = false;
          if (isDraft) {
            keyInput.dataset.draft = item.__draftId;
          }

          let activeKey = item.key || "";

          keyInput.addEventListener("focus", () => {
            keyInput.setSelectionRange(0, keyInput.value.length);
          });
          keyInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
              event.preventDefault();
              keyInput.blur();
            } else if (event.key === "Escape") {
              keyInput.value = activeKey;
              keyInput.blur();
            }
          });
          keyInput.addEventListener("blur", async () => {
            const nextKey = keyInput.value.trim();
            if (!nextKey) {
              setStatus("Key cannot be empty", true);
              if (isDraft) {
                keyInput.value = "";
              } else {
                keyInput.value = activeKey;
              }
              return;
            }
            if (nextKey === activeKey) {
              keyInput.value = activeKey;
              return;
            }
            if (isDraft) {
              activeKey = nextKey;
              item.key = nextKey;
              setStatus("Key ready");
              return;
            }
            try {
              await renameKey(activeKey, nextKey);
              activeKey = nextKey;
              setStatus("Key renamed");
              await fetchTranslations(document.getElementById("search").value);
            } catch (error) {
              setStatus(error.message, true);
              keyInput.value = activeKey;
            }
          });

          const keyTools = document.createElement("div");
          keyTools.className = "key-tools";

          const copyBtn = document.createElement("button");
          copyBtn.type = "button";
          copyBtn.className = "icon-button";
          copyBtn.title = "Copy key";
          copyBtn.textContent = "📋";
          copyBtn.addEventListener("click", async () => {
            if (!activeKey) {
              setStatus("Set a key before copying", true);
              return;
            }
            try {
              await navigator.clipboard.writeText(activeKey);
              setStatus("Key copied to clipboard");
            } catch (_) {
              setStatus("Copy not available in this browser", true);
            }
          });

          const deleteKeyBtn = document.createElement("button");
          deleteKeyBtn.type = "button";
          deleteKeyBtn.className = "icon-button danger";
          deleteKeyBtn.title = "Delete key";
          deleteKeyBtn.textContent = "🗑️";
          deleteKeyBtn.addEventListener("click", async () => {
            if (isDraft) {
              dropDraft(item.__draftId);
              renderTable();
              setStatus("Draft removed");
              return;
            }
            if (!confirm(`Delete key "${activeKey}" for all languages?`)) {
              return;
            }
            if (SAMPLE_MODE) {
              const index = sampleStore.items.findIndex(
                (entry) => entry.key === activeKey,
              );
              if (index === -1) {
                setStatus("Failed to delete key", true);
                return;
              }
              sampleStore.items.splice(index, 1);
              setStatus("Key deleted");
              await fetchTranslations(document.getElementById("search").value);
              return;
            }
            if (!state.currentPath) {
              setStatus("Select a file before deleting keys", true);
              return;
            }
            const deleteParams = new URLSearchParams({ path: state.currentPath });
            const res = await fetch(
              `/api/keys/${encodeURIComponent(activeKey)}?${deleteParams.toString()}`,
              { method: "DELETE" },
            );
            if (res.ok) {
              setStatus("Key deleted");
              await fetchTranslations(document.getElementById("search").value);
            } else {
              let message = "Failed to delete key";
              try {
                const err = await res.json();
                if (err?.error) {
                  message = err.error;
                }
              } catch (_) {
                // ignore
              }
              setStatus(message, true);
            }
          });

          keyTools.appendChild(copyBtn);
          keyTools.appendChild(deleteKeyBtn);

          keyHeader.appendChild(keyInput);
          keyHeader.appendChild(keyTools);

          keyWrapper.appendChild(keyHeader);
          keyCell.appendChild(keyWrapper);
          tr.appendChild(keyCell);

          const translationCell = document.createElement("td");
          translationCell.className = "translation-cell";
          const translationWrapper = document.createElement("div");
          translationWrapper.className = "translation-wrapper";

          // Reference display
          const reference =
            !isDraft && state.referenceLanguage ? referenceFor(item) : null;
          if (reference) {
            const refLine = document.createElement("div");
            refLine.className = "reference-line";

            const refLabel = document.createElement("span");
            refLabel.textContent = formatLanguageDisplay(
              state.referenceLanguage,
            );

            const separator = document.createElement("span");
            separator.textContent = "—";

            const refValue = document.createElement("span");
            refValue.className = "reference-value";
            refValue.textContent = reference.value ? reference.value : "—";

            refLine.appendChild(refLabel);
            refLine.appendChild(separator);
            refLine.appendChild(refValue);

            translationWrapper.appendChild(refLine);
          }

          if (
            state.currentLanguage &&
            !item.translations[state.currentLanguage]
          ) {
            item.translations[state.currentLanguage] = {};
          }
          const translation = state.currentLanguage
            ? item.translations[state.currentLanguage] || {}
            : {};

          const textarea = document.createElement("textarea");
          textarea.className = "translation-input";
          textarea.placeholder = `Enter ${languageLabel(state.currentLanguage || "")} translation`;
          textarea.value = translation.value || "";
          textarea.addEventListener("change", async (event) => {
            if (!state.currentLanguage) {
              setStatus("Select a language before saving", true);
              return;
            }
            if (!activeKey) {
              setStatus("Set a key before saving a translation", true);
              textarea.value = translation.value || "";
              return;
            }
            try {
              await upsertTranslation(
                {
                  key: activeKey,
                  language: state.currentLanguage,
                  value: event.target.value,
                },
                "Translation saved",
              );
              if (isDraft) {
                dropDraft(item.__draftId);
                await fetchTranslations(
                  document.getElementById("search").value,
                );
              } else {
                translation.value = event.target.value;
              }
            } catch (error) {
              setStatus(error.message, true);
              textarea.value = translation.value || "";
            }
          });

          translationWrapper.appendChild(textarea);
          // Auto-resize main translation textarea
          requestAnimationFrame(() => initAutoResize(textarea));

          const pluralVariations =
            (translation.variations && translation.variations.plural) || {};
          const pluralKeys = Object.keys(pluralVariations);

          const pluralList = document.createElement("div");
          pluralList.className = "plural-list";

          pluralKeys.forEach((caseKey) => {
            const entry = pluralVariations[caseKey] || {};
            const row = document.createElement("div");
            row.className = "plural-row";

            const label = document.createElement("label");
            label.textContent = `plural: ${caseKey.toLowerCase()}`;
            row.appendChild(label);

            const rowContent = document.createElement("div");
            rowContent.className = "plural-row-content";

            const variantTextarea = document.createElement("textarea");
            variantTextarea.rows = 1;
            variantTextarea.value = entry.value || "";
            variantTextarea.addEventListener("change", async (event) => {
              if (!activeKey) {
                setStatus("Set a key before saving plural translations", true);
                variantTextarea.value = entry.value || "";
                return;
              }
              const updates = { plural: {} };
              updates.plural[caseKey] = { value: event.target.value };
              try {
                await upsertTranslation(
                  {
                    key: activeKey,
                    language: state.currentLanguage,
                    variations: updates,
                  },
                  `Plural '${caseKey}' saved`,
                );
                if (isDraft) {
                  dropDraft(item.__draftId);
                  await fetchTranslations(
                    document.getElementById("search").value,
                  );
                } else {
                  entry.value = event.target.value;
                }
              } catch (error) {
                setStatus(error.message, true);
                variantTextarea.value = entry.value || "";
              }
            });
            rowContent.appendChild(variantTextarea);
            // Auto-resize plural textarea
            requestAnimationFrame(() => initAutoResize(variantTextarea));

            const deleteVariant = document.createElement("button");
            deleteVariant.type = "button";
            deleteVariant.className = "icon-button danger";
            deleteVariant.title = `Remove ${caseKey} plural`;
            deleteVariant.textContent = "×";
            deleteVariant.addEventListener("click", async () => {
              if (!activeKey) {
                setStatus("Set a key before removing plural forms", true);
                return;
              }
              const updates = { plural: {} };
              updates.plural[caseKey] = { value: null };
              try {
                await upsertTranslation(
                  {
                    key: activeKey,
                    language: state.currentLanguage,
                    variations: updates,
                  },
                  `Plural '${caseKey}' removed`,
                );
                dropDraft(item.__draftId);
                await fetchTranslations(
                  document.getElementById("search").value,
                );
              } catch (error) {
                setStatus(error.message, true);
              }
            });
            rowContent.appendChild(deleteVariant);

            row.appendChild(rowContent);
            pluralList.appendChild(row);
          });

          translationWrapper.appendChild(pluralList);

          // Add plural button and picker to key tools
          const availableCases = PLURAL_CASES.filter(
            (caseKey) => !pluralKeys.includes(caseKey),
          );

          if (availableCases.length > 0) {
            const addPluralBtn = document.createElement("button");
            addPluralBtn.type = "button";
            addPluralBtn.className = "icon-button";
            addPluralBtn.title = "Add plural form";
            addPluralBtn.textContent = "＋ Plural";

            const picker = document.createElement("div");
            picker.className = "plural-picker hidden";

            addPluralBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              if (!activeKey) {
                setStatus("Set a key before adding plural forms", true);
                return;
              }
              picker.classList.toggle("hidden");
            });

            // Close picker when clicking elsewhere
            document.addEventListener("click", (e) => {
              if (!keyTools.contains(e.target)) {
                picker.classList.add("hidden");
              }
            });

            availableCases.forEach((caseKey) => {
              const optionBtn = document.createElement("button");
              optionBtn.type = "button";
              optionBtn.className = "plural-option";
              optionBtn.textContent = caseKey;
              optionBtn.addEventListener("click", async () => {
                if (!activeKey) {
                  setStatus("Set a key before adding plural forms", true);
                  picker.classList.add("hidden");
                  return;
                }
                const updates = { plural: {} };
                updates.plural[caseKey] = { value: "" };
                try {
                  await upsertTranslation(
                    {
                      key: activeKey,
                      language: state.currentLanguage,
                      variations: updates,
                    },
                    `Plural '${caseKey}' added`,
                  );
                  picker.classList.add("hidden");
                  dropDraft(item.__draftId);
                  await fetchTranslations(
                    document.getElementById("search").value,
                  );
                } catch (error) {
                  setStatus(error.message, true);
                }
              });
              picker.appendChild(optionBtn);
            });

            keyTools.appendChild(addPluralBtn);
            keyTools.appendChild(picker);
          }

          translationCell.appendChild(translationWrapper);
          tr.appendChild(translationCell);

          tbody.appendChild(tr);
        });
      }

      async function upsertTranslation(
        payload,
        successMessage = "Translation saved",
      ) {
        const { key, language } = payload;
        if (!language) {
          throw new Error("Select a language before saving");
        }
        if (SAMPLE_MODE) {
          if (!key) {
            throw new Error("Set a key before saving a translation");
          }
          let target = sampleStore.items.find((item) => item.key === key);
          if (!target) {
            target = { key, comment: "", translations: {} };
            sampleStore.items.push(target);
          }
          const translation = target.translations[language] || {};
          if (payload.value !== undefined) {
            translation.value = payload.value;
          }
          if (payload.state !== undefined) {
            translation.state = payload.state;
          }
          if (payload.variations !== undefined) {
            translation.variations = translation.variations || {};
            if (payload.variations.plural) {
              translation.variations.plural = {
                ...(translation.variations.plural || {}),
                ...payload.variations.plural,
              };
            }
          }
          target.translations[language] = translation;
          setStatus(successMessage);
          return;
        }

        const body = { key, language };
        if (!state.currentPath) {
          throw new Error("Select a file before saving a translation");
        }
        body.path = state.currentPath;
        if (payload.value !== undefined) {
          body.value = payload.value;
        }
        if (payload.state !== undefined) {
          body.state = payload.state;
        }
        if (payload.variations !== undefined) {
          body.variations = payload.variations;
        }

        const res = await fetch("/api/translations", {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });

        if (!res.ok) {
          let message = `Failed to save translation (${res.status})`;
          try {
            const errorBody = await res.json();
            if (errorBody?.error) {
              message = errorBody.error;
            }
          } catch (_) {
            // ignore JSON parse errors
          }
          throw new Error(message);
        }

        setStatus(successMessage);
      }

      async function renameKey(oldKey, newKey) {
        if (SAMPLE_MODE) {
          if (
            sampleStore.items.some(
              (item) => item.key === newKey && item.key !== oldKey,
            )
          ) {
            throw new Error("A key with that name already exists");
          }
          const target = sampleStore.items.find((item) => item.key === oldKey);
          if (!target) {
            throw new Error("Key not found");
          }
          target.key = newKey;
          return;
        }
        if (!state.currentPath) {
          throw new Error("Select a file before renaming keys");
        }
        const res = await fetch(`/api/keys/${encodeURIComponent(oldKey)}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ new_key: newKey, path: state.currentPath }),
        });
        if (!res.ok) {
          let message = `Failed to rename key (${res.status})`;
          try {
            const errorBody = await res.json();
            if (errorBody?.error) {
              message = errorBody.error;
            }
          } catch (_) {
            // ignore JSON parse errors
          }
          throw new Error(message);
        }
      }

      function setStatus(message, isError = false) {
        const status = document.getElementById("status");
        status.textContent = message;
        status.className = isError ? "status error" : "status";
        if (message) {
          setTimeout(() => {
            status.textContent = "";
            status.className = "status";
          }, 3500);
        }
      }

      document
        .getElementById("file-select")
        .addEventListener("change", async (event) => {
          const nextPath = event.target.value || null;
          if (SAMPLE_MODE) {
            return;
          }
          if (!nextPath) {
            state.currentPath = null;
            state.languages = [];
            state.items = [];
            state.drafts = [];
            renderLanguageControls();
            renderTable();
            updateControlState();
            return;
          }
          if (state.currentPath === nextPath) {
            return;
          }
          state.currentPath = nextPath;
          state.drafts = [];
          await fetchLanguages();
          const query = document.getElementById("search").value || "";
          await fetchTranslations(query);
        });

      document
        .getElementById("language-select")
        .addEventListener("change", (event) => {
          const next = event.target.value;
          if (!next || state.currentLanguage === next) {
            return;
          }
          state.currentLanguage = next;
          document.getElementById("language-header").textContent =
            translationHeaderText();
          renderTable();
        });

      document
        .getElementById("reference-select")
        .addEventListener("change", (event) => {
          const next = event.target.value || null;
          if (state.referenceLanguage === next) {
            return;
          }
          state.referenceLanguage = next;
          renderTable();
        });

      document.getElementById("refresh").addEventListener("click", async () => {
        await loadFiles();
      });

      document.getElementById("search").addEventListener("input", (event) => {
        if (!state.currentPath && !SAMPLE_MODE) {
          return;
        }
        const query = event.target.value;
        fetchTranslations(query);
      });

      document
        .getElementById("add-translation")
        .addEventListener("click", () => {
          if (!state.currentLanguage) {
            setStatus("Select a language before adding translations", true);
            return;
          }
          if (!state.currentPath && !SAMPLE_MODE) {
            setStatus("Select a file before adding translations", true);
            return;
          }
          const draftId = `draft-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
          const draft = {
            __draft: true,
            __draftId: draftId,
            key: "",
            comment: "",
            translations: {},
          };
          state.drafts.unshift(draft);
          renderTable();
          window.requestAnimationFrame(() => {
            const input = document.querySelector(
              `.key-input[data-draft="${draftId}"]`,
            );
            if (input) {
              input.focus();
            }
          });
        });

      (async function init() {
        await loadFiles();
      })();
    </script>
  </body>
</html>
